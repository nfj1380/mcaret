#'Plots multi-response 2D profile plots to help interpret interactions
#'@param mrIMLconverts_list A \code{list} list of iml objects generated by MrIMLconverts
#'@param featureA A \code{character} the name of the first feature the interaction pair
#'@param featureB A \code{character} the name of the second feature the interaction pair
#'@param mode \code{character}'classification' or 'regression' i.e., is the generative model a regression or classification?
#'@param grid.size \code{numeric} number of grid points to define the resolution of partial dependencies or ALEs across feature space. . 
#'@param method \code{character} method used to construct the 2D plot. Can be either 'ale' (default) or 'pdp'
#'@details This function computes multivariate 2D profile plots for feature pairs of interest by taking the average prediction across feature space for all responses.
#' This plot can be generated based on accumulated feature effects (ALEs) or partial dependencies.
#' We recommend ALEs (see Molnar, 2019) as they are the most reliable and do not calculate predictions for unrealistic combinations of features.
#' If there are no interactions the ALE estimation will be 0. Figures can be further edited using ggplot2.
#'
#'@example
#'yhats<- mrIMLpredicts(X=X,Y=Y, model1=model1, balance_data='no', model='classification') 
#'mrIMLconverts_list <- MrIMLconverts(yhats, model='classification')

#'featureA = 'Relatedness.PCO1'
#'featureB = 'Relatedness.PCO2'

#'test_plot <- mrProfile2D (mrIMLconverts_list, featureA, 
#'featureB,  model='classification',
#' grid.size=30)
#'test <- mrProfile2D (mrIMLconverts_list, featureA, 
#' featureB,  model='classification',
#' grid.size=30, method = "pdp")
#'
#'plot(test ) + theme(text = element_text(family="Serif"))+theme_bw()

#'\dontrun{
#'
#'@export 
#'

mrProfile2D <- function(mrIMLconverts_list, featureA, featureB,
                    mode='regression', grid.size=30, method = "ale"){
  
  n_response<- length(mrIMLconverts_list)

#sets up feature effect object
  profile_1 <- FeatureEffect$new(mrIMLconverts_list[[1]],
                           c(paste0(featureA),paste0(featureB)), 
                           grid.size = grid.size, method = paste0(method))

  #imp <- FeatureImp$new(mrIMLconverts_list[[1]], loss = "mae")
#select positive (1) class. Could add functionality to select 0 class too.

  if (mode=='classification'){

    profile_1_pos <- profile_1$results %>% filter (.class=='.pred_1')
    }

  im <- lapply(seq(1:n_response), function(i){ 
  

          profile2D <- FeatureEffect$new(mrIMLconverts_list[[i]], ###
                           c(paste0(featureA),paste0(featureB)), 
                           grid.size = grid.size, method = paste0(method)
                           )
  
             # if (mode=='regression'){
             #   profile2D$results %>%  select (-c(.type))
             #   }
             # 
  #select positive class for classification problems
              if (mode=='classification'){
    
                profile2D$results <- profile2D$results %>% filter (.class=='.pred_1')
                profile2D$results %>%  select (-c(.type, .class))
                
              } else {profile2D$results %>%  select (-c(.type))}
        
                           })##
  
 #would be good to find an alternative to aaply
#this takes the mean ale/pdp for each predictor combination
ans1 <-  aaply(laply(im, as.matrix), c(2, 3), mean)

  if (mode=='classification'){
    
    #have to reattach class data
    classInfo <- profile_1_pos  %>% select(.class)
    
       ans1 <- cbind(.class = classInfo, ans1)
  }

profile_1$results <- as.data.frame(ans1)
  #plot(ALE_1 )
  
return(profile_1)

}

