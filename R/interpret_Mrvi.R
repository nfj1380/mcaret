#'Plots global importance (i.e. cumulative importance of all features for all response variables) and individual response importance.
#'@param VI A \code{dataframe} data frame generated from mrvip function 
#'@param Y A \code{dataframe} response data set
#'@param X A \code{dataframe} feature data set
#'@param modelPerf A \code{dataframe} data frame generated by modelPerf function
#'@param cutoff A \code{numeric} determines Mathews correlation coefficient (mcc) threshold for displaying individual reponse model. Default is 0.5
#'@param mode \code{character}'classification' or 'regression' i.e., is the generative model a regression or classification?
#'@details
#'1st plot: 
#'and individual response feature plots (2nd plot). Requires object generated from the R function mrvip as well as feature data (Y).
#'Variables also need to be grouped to allow for easier interpretation. 
#'
#'@examples
#'\dontrun{
#'
#'groupCov <- c(rep ("Host_characteristics", 1),rep("Urbanisation", 3), rep("Vegetation", 2), rep("Urbanisation",1), rep("Spatial", 2), 
#'rep('Host_relatedness', 6),rep ("Host_characteristics", 1),rep("Vegetation", 2), rep("Urbanisation",1))
#'interpret_Mrvi(VI=VI,  X=fData,Y=FeaturesnoNA, modelPerf=ModelPerf, groupCov, cutoff= 0.5)}
#'@export 

interpret_Mrvi <- function (VI, modelPerf, Y, X, groupCov=NULL, cutoff= 0.2,  mode='regression'){
  
  #----------------------------------------------------------------
  #Global importance
  #----------------------------------------------------------------
  
  #for interpretation of group features.
  
  rs <- as.data.frame( rowSums(VI)/sum(VI)) #make it a proportion
  rsA <- rownames_to_column(rs)
  n_features <- names(X)
  
  if (!is.null(groupCov)) { 
    
    rsA <- cbind(rsA, groupCov) # attach group info
    names(rsA)[2] <- c('prop')
    rsA$row <- 1 #dummy x axis
    
    p1 <-  ggplot(rsA, aes(fill= groupCov, y=prop, x= row)) + 
      theme_bw()+
      labs(y= "Cumulative importance")+
      geom_bar(position="stack", stat="identity") +
      scale_fill_viridis(discrete = T)+
      theme(axis.title.x=element_blank(),
            axis.text.x=element_blank(),
            axis.ticks.x=element_blank())+
      labs(fill='Feature') 

    #----------------------------------------------------------------
    #Individual response importance
    #----------------------------------------------------------------
    
    trans <- as.data.frame(t(VI))
    
    if (mode=='classification'){
      
      combi <- bind_cols(modelPerf[1]$mcc,trans) %>% 
        na.omit() #nas mean the model didn't work properly remove. Should provide a warning perhaps?
      
      combi$mcc<- as.numeric(as.character(combi$mcc)) #have to make mcc numeric again.
      combiF <- filter(combi, mcc > cutoff) 
      # poorly performing models don't get included. COuld make this user defined. Need a warning here
    
      combiF$model_name <- NULL #don't need these columns anymore. May be nice to print them on plot?
      
    }
    if (mode=='regression'){
      
      combi <- bind_cols(modelPerf[1]$rsquared, trans) %>% 
        na.omit() #nas mean the model didn't work properly remove. Should provide a warning perhaps?
      
      combi$rsquared<- as.numeric(as.character(combi$rsquared)) #have to make mcc numeric again.
      combiF <- filter(combi, rsquared > cutoff)  
      
      combiF$rsquared <- NULL
      
    }
    
    #switch the dataframe back around again.
    combiFT <- as.data.frame(t(combiF))
    #combiFT <- as.data.frame(t(combiF)) %>%  janitor::row_to_names(row_number = 1)
    #combiFT <- as.data.frame(t(combiF)) %>% rownames_to_column(var = "predictors")
    #------------------------------------------------------------------  
    
    data_long <- gather(combiFT,  key ='response', value = importance) #turns this wide frame into something more suitable to plot
    
    charvec <- rep(n_features, length(combiFT)) #create a vector of feature names
    
    charvecGroup <- rep(groupCov, length(combiFT)) #make it easier to read 
    
    finaldf <- as.data.frame(cbind(data_long, charvec)) #if we want ungrouped features. COuld add this functionality
    finaldfg <- as.data.frame(cbind(data_long, charvecGroup))
    
    finaldf$importance <- as.numeric(finaldf$importance) 
    finaldfg$importance <- as.numeric(finaldfg$importance)
    
    #not the biggest fan of barplots  - but they are the easiest to see in this case.
    
    p2 <- ggplot(finaldfg, aes(fill=charvecGroup  , y=importance, x=charvecGroup )) + 
      geom_bar(position="dodge", stat="identity") +
      viridis::scale_fill_viridis(discrete = T, option = "E") +
      ggtitle("Individual response models") +
      facet_wrap(~response) +
      theme(axis.title.x=element_blank(),
            axis.text.x=element_blank(),
            axis.ticks.x=element_blank())+
      labs(fill='Feature set')  
    }
  
  #-----------------------------------------------------------------------------------------------------------  
  if (is.null(groupCov)) {
    
    names(rsA)[2] <- c('prop')
    rsA$row <- 1 #dummy x axis
    
    p1 <-  ggplot(rsA, aes(y=reorder(rowname, prop), x= prop)) + 
      geom_bar(stat="identity")+
      theme_bw()+
      labs(y= "Feature", x='Cumulative importance')
    
    #----------------------------------------------------------------
    #Individual response importance
    #----------------------------------------------------------------
    
    trans <- as.data.frame(t(VI))
    # colnames(trans) <- n_features
    
    if (mode=='classification'){
      
      combi <- bind_cols(mcc=modelPerf[[1]]$mcc, trans ) 
      combi[is.na(combi)] <- -1 
      
      combi$mcc<- as.numeric(as.character(combi$mcc)) #have to make mcc numeric again. COuld use ppv or anything else
      combiF <- filter(combi, mcc > cutoff) 
      
      combiF$mcc <- NULL
      
    # poorly performing models don't get included. Could make this user defined. Need a warning here
 
    }
    
    if (mode=='regression'){
      
      combi <- bind_cols(mcc=modelPerf[[1]]$rsquared, trans ) 
      combi$rsquared<- as.numeric(as.character(combi$rsquared)) #have to make mcc numeric again.
      combiF <- filter(combi, rsquared > cutoff)  
      combiF$response <- as.character(combiF$response) 
      
      combiF$rsquared <- NULL #not needed anymore

    }
    
    combiFT <- as.data.frame(t(combiF))

    #------------------------------------------------------------------  
    
    data_long <- gather(combiFT,  key ='response', value = importance) #turns this wide frame into something more suitable to plot
    
    charvec <- rep(n_features, length(combiFT)) #create a vector of feature names
    
    finaldf <- as.data.frame(cbind(data_long, charvec)) #if we want ungrouped features. COuld add this functionality
    #finaldfg <- as.data.frame(cbind(data_long, charvecGroup))
    
    finaldf$importance <- as.numeric(finaldf$importance) 
    # finaldfg$importance <- as.numeric(finaldfg$importance)
    
  
    p2 <- ggplot(finaldf, aes(fill=charvec  , y=importance, x=charvec )) + 
      geom_bar(position="dodge", stat="identity") +
      viridis::scale_fill_viridis(discrete = T, option = "E") +
      ggtitle("Individual response models") +
      facet_wrap(~response) +
      # theme_ipsum() +
      theme(axis.title.x=element_blank(),
            axis.text.x=element_blank(),
            axis.ticks.x=element_blank())+
      labs(fill='Feature set') #could be a nice extension to add mcc/spec/sens to the model
  } 
  
  #------------------------------------------------------------------  
  #Importance PCA plot. Responses with similar importance scores group together
  #------------------------------------------------------------------    
  
  a.pca <- trans %>% 
    
    prcomp() # do PCA
  
  #-----------------------------------------------------------------------------------------
  #outlier detection
  
  uscores <- a.pca$x %>%
    as.data.frame()
  
  outL <- apply(uscores, 2, function(x) which( (abs(x - median(x)) / mad(x)) > 6 ))
  
  #-----------------------------------------------------------------------------------------
  
  pca_val <-  a.pca  %>%
    tidy(matrix = "eigenvalues")
  
  p3 <- a.pca %>%
    augment(trans) %>% 
    ggplot(aes(.fittedPC1, .fittedPC2)) + 
    geom_point() + 
    ggrepel::geom_label_repel(aes(label = rownames(trans)),
                     box.padding   = 0.35, 
                     point.padding = 0.5,
                     label.size = 0.1,
                     segment.color = 'grey50') +
    theme_bw()
  
  #print(p3)
  
  p4 <- a.pca %>%
    tidy(matrix = "eigenvalues") %>%
    ggplot(aes(PC, percent)) +
    geom_col(fill = "#56B4E9", alpha = 0.8) +
    scale_x_continuous(breaks = 1:9) +
    scale_y_continuous(
      labels = scales::percent_format(),
      expand = expansion(mult = c(0, 0.01))
    ) +
    theme_bw() 
  
  combined_plot <- plot_grid(p1, p2, p3, p4, rel_heights = c(1, 0.5), labels = "auto")
  
  #readline(prompt="Press [enter] to plot the axis loadings") 
  # library(gridExtra)
  #grid.arrange(arrangeGrob(p1,p3,p4, ncol=1, nrow=3),
  #  arrangeGrob(p2,ncol=1, nrow=1),  heights=c(4,2), widths=c(1,2))
  
  #for 3D plots that are interactive.
  #adapt <- c(rep('diag', 2), rep('gradient', 2), rep('habitat', 2), rep('neutral', 94) )
  #uscores <- as.data.frame(cbind(uscores,adapt))
  # p4 <- plotly::plot_ly(uscores, x=~PC1, y=~PC2, z=~PC3, color = ~adapt, colors = c('#BF382A', '#0C4B8E', '#1DF20D','#B9B930' )) %>% 
  # plotly::add_markers()
  
  return(list(outLiers=outL,  pca_val=pca_val, scores=uscores, combined_plot, p2,p3))
  
}
