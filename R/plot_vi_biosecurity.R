#'Plots global importance (i.e. cumulative importance of all features for all response variables) and individual response importance.
#'@param VI A \code{dataframe} dataframe generated from mrvip function 
#'@param Y A \code{dataframe} response dataset
#'@param X A \code{dataframe} feature dataset
#'@param modelPerf A \code{dataframe} dataframe generated by modelPerf function
#'@param cutoff A \code{numeric} determines  mathews correlation coefifcent (mcc) threshold for displaying individual reponse model. Default is 0.5
#'@param mode \code{character}'classification' or 'regression' i.e., is the generative model a regression or classification?
#'@details
#'1st plot: 
#'and individual reponse feature plots (2nd plot). Requires object generated from the R function mrvip as well as feature data (Y).
#'Variables also need to be grouped to allow for easier interpretation. 
#'@examples
#'\dontrun{
#'groupCov <- c(rep ("Host_characteristics", 1),rep("Urbanisation", 3), rep("Vegetation", 2), rep("Urbanisation",1), rep("Spatial", 2), 
#'rep('Host_relatedness', 6),rep ("Host_characteristics", 1),rep("Vegetation", 2), rep("Urbanisation",1))
#'plot_vi(VI=VI,  X=fData,Y=FeaturesnoNA, modelPerf=ModelPerf, groupCov, cutoff= 0.5)}
#'@export 

plot_vi_biosecurity <- function (VI, modelPerf, Y, X, groupCov=NULL, cutoff= 0.2, plot.pca='no', mode ='regression' ){

  row.names(VI) <- names(Y)
  n_features <-  names(VI)
  VIa <-  as.data.frame(t(VI))
  #----------------------------------------------------------------
  #Global importance
  #----------------------------------------------------------------

  #for interpretation of group features.
  
    rs <- as.data.frame( rowSums(VIa)/sum(VIa) ) #make it a proportion
      rsA <- rownames_to_column(rs)
      
  # if (!is.null(groupCov)) { 
  #   
  #  
  #   rsA <- cbind(rsA, groupCov) # attach group info
  # names(rsA)[2] <- c('prop')
  #   rsA$row <- 1 #dummy x axis
  #   
  #   
  #  p1 <- ggplot(rsA, aes(fill= groupCov, y=prop, x= row)) + 
  #        labs(y= "Cumulative importance") +
  #         geom_bar(position="stack", stat="identity") +
  #         scale_fill_viridis(discrete = T) +
  #         theme(axis.line = element_line(size=0.8, colour = "black"),
  #          axis.text.x = element_text(colour="black", size = 18),
  #          axis.text.y=element_text(colour="black", size = 18),
  #          axis.title.x = element_text(size = 22, face = "bold"),
  #          axis.title.y = element_text(size = 22, face = "bold"),
  #          text = element_text(size = 22, face = "bold"),
  #          strip.background = element_rect(color="black",size=1.5, linetype="solid")) +
  #         labs(fill='Feature')
  #  
  #  print(p1)}
  #  readline(prompt="Press [enter] to continue for the top individual models")

    #----------------------------------------------------------------
    #Individual response importance
    #----------------------------------------------------------------
# 
#   trans <- as.data.frame(VI)
#   features <-  colnames(trans)
# 
#   combi <- bind_cols(ModelPerf[1], trans ) %>%
#   na.omit() #nas mean the model didn't work properly remove. Should provide a warning perhaps?

  # if (mode =='classification'){
  # 
  # combi$mcc<- as.numeric(as.character(combi$mcc)) #have to make mcc numeric again.
  # combiF <- filter(combi, mcc > cutoff)
  # # poorly performing models don't get included. COuld make this user defined. Need a warning here
  # combiF$response <- as.character(combiF$response)
  # 
  # combiF$model_name <- NULL #don't need these columns anymore. May be nice to print them on plot?
  # combiF$mcc <- NULL
  # combiF$sensitivity <- NULL
  # combiF$specificity <- NULL
  # combiF$roc_AUC <- NULL
  # combiF$prevalence <- NULL
  # 
  # }
  # if (mode =='regression'){
  # 
  #   combi$rsquared<- as.numeric(as.character(combi$rsquared)) #have to make mcc numeric again.
  #   combiF <- filter(combi, rsquared > cutoff)
  #   combiF$response <- as.character(combiF$response)
  # 
  #   combiF$rmse <- NULL #don't need these columns anymore. May be nice to print them on plot?
  #   combiF$rsquared <- NULL
  #   combiF$model_name <- NULL
  # 
  # }
  #   combiFT <- as.data.frame(t(combiF)) %>%  row_to_names(row_number = 1)
  # 
  # #------------------------------------------------------------------
  # 
  # data_long <- gather(combiFT,  key ='response', value = importance) #turns this wide frame into something more suitable to plot
  # 
  # charvec <- rep(n_features, length(combiFT)) #create a vector of feature names
  # 
  # charvecGroup <- rep(groupCov, length(combiFT)) #make it easier to read
  # 
  # finaldf <- as.data.frame(cbind(data_long, charvec)) #if we want ungrouped features. COuld add this functionality
  # finaldfg <- as.data.frame(cbind(data_long, charvecGroup))
  # 
  # finaldf$importance <- as.numeric(finaldf$importance)
  # finaldfg$importance <- as.numeric(finaldfg$importance)
#
#   #not the biggest fan of barplots  - but they are the easiest to see in this case.
#
#   p2 <- ggplot(finaldfg, aes(fill=charvecGroup  , y=importance, x=charvecGroup )) + 
#     geom_bar(position="dodge", stat="identity") +
#     scale_fill_viridis(discrete = T, option = "E") +
#     ggtitle("Individual response models") +
#     facet_wrap(~response) +
#     theme_ipsum() +
#     theme(axis.title.x=element_blank(),
#         axis.text.x=element_blank(),
#         axis.ticks.x=element_blank())+
#   labs(fill='Feature set') #could be a nice extension to add mcc/spec/sens to the model
# #theme(legend.position="none") + #I like the legend personally rather than lots of x axis text.
#   
# readline(prompt="Press [enter] to plot individual variable importance summaries")  
#   print(p2)
#   }
#     
#     
# #-----------------------------------------------------------------------------------------------------------  
  if (is.null(groupCov)) {

#FeatureName <- as.data.frame(names(Y))   #this is more flexible
         # FNameOrdered <- FeatureName[order(FeatureName$'names(Y)'),]

    #rsA <- cbind(rsA, n ) # add featue names back

    names(rsA)[2] <- c('prop')
    rsA$row <- 1 #dummy x axis


    p1 <-  ggplot(rsA, aes(y=reorder(rowname, prop), x= prop)) +
      geom_bar(stat="identity")+
      theme_bw()+
      labs(y= "Features", x='Cumulative importance') +
      theme_bw()+
      theme(#axis.line.x = element_line(size = 0.4, colour = "black"),
        #axis.line.y = element_line(size = 0.4, colour = "black"),
        axis.line = element_line(size=0.8, colour = "black"),
        #axis.ticks.x = element_blank(),
        #axis.title.x=element_blank(),
        #axis.text.x=element_blank(),
        #legend.position = "none",
        #panel.grid.major = element_blank(),
        #panel.grid.minor = element_blank(),
        #panel.border = element_blank(),
        #panel.background = element_blank(),
        axis.text.x=element_text(colour="black", size = 14),
        axis.text.y=element_text(colour="black", size = 14, lineheight = 0.7),
        axis.title.x = element_text(size = 20),
        axis.title.y = element_text(size = 20), #axis.title.y = element_text(margin = margin(t = 0, r = 10, b = 0, l = 7))
        text = element_text(size = 14, face = "bold"),
        strip.background = element_rect(
          color="black",size=1.5, linetype="solid"
        )
      )
    
    print(p1)

    readline(prompt="Press [enter] to plot individual variable importance summaries")}}
# #----------------------------------------------------------------
#     #Individual response importance
# #----------------------------------------------------------------
#     
#     trans <- as.data.frame(VI)
#    # colnames(trans) <- n_features
#     
#     combi <- bind_cols(ModelPerf[1], trans ) 
#       combi[is.na(combi)] <- -1 #nas mean the model didn't work properly remove. Should provide a warning perhaps?
#     
#     if (mode =='classification'){
#       
#       combi$mcc<- as.numeric(as.character(combi$mcc)) #have to make mcc numeric again.
#       combiF <- filter(combi, mcc > cutoff) 
#       # poorly performing models don't get included. COuld make this user defined. Need a warning here
#       combiF$response <- as.character(combiF$response) 
#       
#       combiF$model_name <- NULL #don't need these columns anymore. May be nice to print them on plot?
#       combiF$mcc <- NULL
#       combiF$sensitivity <- NULL
#       combiF$specificity <- NULL
#       combiF$roc_AUC <- NULL
#       combiF$prevalence <- NULL
#       
#     }
#     if (mode =='regression'){
#     
#       
#       combi$rsquared<- as.numeric(as.character(combi$rsquared)) #have to make mcc numeric again.
#       combiF <- filter(combi, rsquared > cutoff)  
#       combiF$response <- as.character(combiF$response) 
#       
#       combiF$rmse <- NULL #don't need these columns anymore. May be nice to print them on plot?
#       combiF$rsquared <- NULL
#       combiF$model_name <- NULL 
#       
#       
#     }
#     
#     combiFT <- as.data.frame(t(combiF)) %>%  row_to_names(row_number = 1) 
#     
#       #------------------------------------------------------------------  
#       
#       data_long <- gather(combiFT,  key ='response', value = importance) #turns this wide frame into something more suitable to plot
#       
#       charvec <- rep(n_features, length(combiFT)) #create a vector of feature names
#       
#       #charvecGroup <- rep(groupCov, length(combiFT)) #make it easier to read 
#       
#       finaldf <- as.data.frame(cbind(data_long, charvec)) #if we want ungrouped features. COuld add this functionality
#       #finaldfg <- as.data.frame(cbind(data_long, charvecGroup))
#       
#       finaldf$importance <- as.numeric(finaldf$importance) 
#      # finaldfg$importance <- as.numeric(finaldfg$importance)
#       
#       #not the biggest fan of barplots  - but they are the easiest to see in this case.
#       
#       p2 <- ggplot(finaldf, aes(fill=charvec  , y=importance, x=charvec )) + 
#         geom_bar(position="dodge", stat="identity") +
#         scale_fill_viridis(discrete = T, option = "E") +
#         ggtitle("Individual response models") +
#         facet_wrap(~response) +
#         theme_ipsum() +
#         theme(axis.title.x=element_blank(),
#               axis.text.x=element_blank(),
#               axis.ticks.x=element_blank())+
#         labs(fill='Feature set') #could be a nice extension to add mcc/spec/sens to the model
#       #theme(legend.position="none") + #I like the legend personally rather than lots of x axis text.
#       
#       print(p2)
#     }
#       #------------------------------------------------------------------  
#       #Importance PCA plot. Responses with similar importance scores group together
#       #------------------------------------------------------------------    
#       
#       
#       if (plot.pca=='yes'){ # impossible to read with many responses
#         
#         readline(prompt="Press [enter] to plot the importance PCA plot")  
#         
#         # a1 <- a[,-1] %>%  mutate_if( is.factor, ~ as.numeric(as.character(.x))) #this is a handy function
#         #row.names(a1) <- a$rowname
#         #trans <- as.data.frame(t(VI) )
#         
#         a.pca <- rda(trans) #this includes all respoinses
#         
#         uscores <- data.frame(a.pca$CA$u)
#        # uscores <- data.frame(test$CA$u)
#         
#         p3 <- ggplot(uscores  , aes(x = PC1, y = PC2)) + 
#           geom_point() + 
#           geom_label_repel(aes(label = rownames(trans)),
#                            box.padding   = 0.35, 
#                            point.padding = 0.5,
#                            label.size = 0.1,
#                            segment.color = 'grey50') +
#           theme_bw()
#         #  geom_text(data = vscores, aes(x = PC1, y = PC2, label = rownames(vscores)), col = 'red')
#         # geom_text(data = vscores, aes(x = PC1, y = PC2, label = rownames(vscores)), col = 'red')
#         print(p3)
#       }
#       #for 3D plots that are interactive.
#        #adapt <- c(rep('diag', 2), rep('gradient', 2), rep('habitat', 2), rep('neutral', 94) )
#       #uscores <- as.data.frame(cbind(uscores,adapt))
#       # p4 <- plotly::plot_ly(uscores, x=~PC1, y=~PC2, z=~PC3, color = ~adapt, colors = c('#BF382A', '#0C4B8E', '#1DF20D','#B9B930' )) %>% 
#         # plotly::add_markers()
#    
#        if(plot.pca=='no'){plotpc=0}
#       }
