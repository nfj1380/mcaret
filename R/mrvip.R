#'Wrapper to estimate model-agnostic variable importance for multi-response models. 
#'@param yhats A \code{list} is the list generated by mrIMLpredicts
#'@param X  A \code{dataframe} is the feature data 
#'@details Calculates variable importance using based on partial dependencies but could do permutations as well (more memory intensive).
#' Key input is the object created by MrIML. Can be plotted with the plot_vi function.
#' @example 
#' VI <- mrVip(yhats, X=X)
#' groupCov <- c(rep ("Host_characteristics", 1),rep("Urbanisation", 3), rep("Vegetation", 2), rep("Urbanisation",1), rep("Spatial", 2), 
#' rep('Host_relatedness', 6),rep ("Host_characteristics", 1),rep("Vegetation", 2), rep("Urbanisation",1))  
#' plot_vi(VI=VI,  X=X,Y=Y, modelPerf=ModelPerf, groupCov, cutoff= 0.5)
#'@export 

mrVip <- function (yhats, X){ 
  
  n_response<- length(yhats) ###
  n_features <- sort(names(X))
  
  modList <- yhats %>% purrr::map(pluck('mod1_k')) #extracts model ###
  
  im <- lapply(seq(1:n_response), function(i){ #uses monte carlo CV. COuld make parallel if needed.
    
    imp <- modList[[i]]%>%  ###
      pull_workflow_fit()
    
    imp$fit$coefficients[is.na(imp$fit$coefficients)] <- 0#some algorithms will bring back NA coefficents
    
    impVI <- vi(imp, num_features=length(X)) 
    impD <- impVI%>% #impVI$data
      arrange(Variable)%>% 
      purrr::pluck("Importance")
    names(impD) <- n_features
    
    missing <- imp$fit$coefficients[is.na(imp$fit$coefficients)] 
    missing[is.na(missing)] <- 0
    impDcombined <- c(impD, missing)
  })
  
  ImpGlobal <- as.data.frame(do.call(rbind, im))
  
  #if(nrow(ImpGlobal) > n_response) {
  

    #ImpGlobal <- ImpGlobal %>% filter(!grepl('Sign', rownames(ImpGlobal)))
    
 # }
  
}