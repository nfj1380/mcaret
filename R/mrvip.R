#'Wrapper to estimate model-agnostic variable importance for multi-response models. 
#'@param yhats A \code{list} is the list generated by mrIMLpredicts
#'@param X  A \code{dataframe} is the feature data 
#'@details Calculates variable importance using based on partial dependencies but could do permutations as well (more memory intensive).
#' Key input is the object created by MrIML. Can be plotted with the plot_vi function.
#' @example 
#' VI <- mrVip(yhats, X=X)
#' groupCov <- c(rep ("Host_characteristics", 1),rep("Urbanisation", 3), rep("Vegetation", 2), rep("Urbanisation",1), rep("Spatial", 2), 
#' rep('Host_relatedness', 6),rep ("Host_characteristics", 1),rep("Vegetation", 2), rep("Urbanisation",1))  
#' plot_vi(VI=VI,  X=X,Y=Y, modelPerf=ModelPerf, groupCov, cutoff= 0.5)
#'@export 


mrVip <- function (yhats, X){ 
  
  n_response<- length(yhats) 
  n_features <- sort(names(X))
  n_features_df <-data.frame(Variable=n_features)
  
  modList <- yhats %>% purrr::map(pluck('mod1_k')) #extracts model ###
  
  im <- lapply(seq(1:n_response), function(i){ #uses monte carlo CV. COuld make parallel if needed.
    
    imp <- modList[[i]] %>%  ###
      extract_fit_parsnip() #pull workflow deprecated
    #pull_workflow_fit()
    
    impVI <- vip::vi(imp,feature_names= n_features,  ice = TRUE)  
    
    miss <- anti_join(n_features_df , impVI, by="Variable")
    z <- rep(0,nrow(miss))
    
    miss_df <- data.frame(Variable=miss, Importance=z) 
    
    impDcombined <- rbind(impVI,miss_df ) %>% 
      arrange(Variable)
    
    impDcombined_names <-  impDcombined %>% column_to_rownames(var="Variable") 
    
  })
  
  ImpGlobal <- as.data.frame(do.call(cbind, im)) 
  ImpGlobal  <- as.data.frame(t(ImpGlobal))
}