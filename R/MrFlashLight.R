#'mrFlashlight:  Wrapper to run multi-response model agnostic interpretable machine learning analyses. 
#.
#'@param yhats A \code{list} is the list generated by mrIMLpredicts
#'@param Y A \code{dataframe} is a response variable data set (species, OTUs, SNPs etc)
#'@param X  A \code{dataframe} is the feature data set
#'@param response \code{character} single' selects one response, 'multi' selects all responses
#'@param index \code{numeric} selects which response to create a flashlight object for. Only used when 'single' is selected. The order is the same as 'Y'.
#'@param predict_function  \code{function}  user specified predict function
#'
#'@details The aim of this function is to enable users to utilize interpretable machine learning methods
#'to understand their multi-response and single response models
#' 
#' @example 
#' #single response
#' fl <- mrFlashlight(yhats, X, Y, response = "single", index=1)
#'
#'plot(light_performance(fl), fill = "orange") + labs(x = element_blank())
#'
#'plot(light_breakdown(fl , new_obs = cbind(X, Y)[1, ]),by = X, v=Y) #prints all responses - need to fix but could be quite handy.
#'
#'int <- light_interaction(fl, pairwise=TRUE) #not working, but possible!
#'
#'Multiple response
#' flashlightObj <- mrFlashlight(yhats, X, Y, response = "multi")
#' @export 

mrFlashlight <- function(yhats, X, Y, response = "multi", index = 1, model = "regression", predict_function=NULL) {
  
  if (model == "classification") {
    
    
    
    # Prediction function
    
    if(is.null(predict_function)){
      
    pred_fun <- function(m, dat) {
      
      predict(
        
        m, dat[, colnames(X), drop = FALSE],
        
        #data.matrix(dat[, colnames(Y), drop = FALSE]),
        
        type = "prob"
        
      )[[".pred_1"]]
      
    }
    }
    if (!is.null(predict_function)){
      
      pred_fun <- predict_function
    }
    
    
    # List of metrics
    
    metrics = list(
      
      logloss = MetricsWeighted::logLoss,
      
      `ROC AUC` = MetricsWeighted::AUC,
      
      `% Dev Red` = MetricsWeighted::r_squared_bernoulli
      
    )
    
    
    
    # Create explainer
    
    if (response == "single") {
      
      mfl <- flashlight(
        
        model = yhats[[index]]$mod1_k, #change the index to focus on other SNPs
        
        label = colnames(Y)[index],
        
        data = cbind(Y, X),
        
        y = colnames(Y)[index],
        
        predict_function = pred_fun,
        
        metrics = metrics
        
      )
      
    } else if(response == "multi") {
      
      models <- lapply(yhats, `[[`, "mod1_k")
      
      fl_list <- vector("list", length(yhats))
      
      for (i in seq_along(fl_list)) {
        
        fl_list[[i]] <- flashlight(
          
          model = yhats[[i]]$mod1_k,
          
          label = colnames(Y)[i],
          
          y = colnames(Y)[i]
          
        )
        
      }
      
      mfl <- multiflashlight(
        
        fl_list,
        
        data = cbind(Y, X),
        
        predict_function = pred_fun,
        
        metrics = metrics
        
      )
      
    }
    
  }
  
  
  
  if (model == "regression") { 
    
    
    
    # Prediction function
    
    pred_fun <- function(m, dat) {
      
      predict(m, dat[, colnames(X), drop = FALSE])[[".pred"]]
      
    }
    
    
    
    # List of metrics
    
    metrics = list( 
      
      rmse = MetricsWeighted::rmse,
      
      `R-squared` = MetricsWeighted::r_squared
      
    )
    
    
    
    # Create explainer
    
    if (response == "single") {
      
      mfl <- flashlight(
        
        model = yhats[[index]]$mod1_k, #change the index to focus on other SNPs
        
        label = colnames(Y)[index],
        
        data = cbind(Y, X),
        
        y = colnames(Y)[index],
        
        predict_function = pred_fun,    #predict_function = pred_fun,
        
        metrics = metrics
        
      )
      
    } else if (response == "multi") {
      
      models <- lapply(yhats, `[[`, "mod1_k")
      
      fl_list <- vector("list", length(yhats))
      
      for (i in seq_along(fl_list)) {
        
        fl_list[[i]] <- flashlight(
          
          model = yhats[[i]]$mod1_k,
          
          label = colnames(Y)[i],
          
          y = colnames(Y)[i]
          
        )
        
      }
      
      mfl <- multiflashlight(
        
        fl_list,
        
        data = cbind(Y, X),
        
        predict_function = pred_fun,
        
        metrics = metrics
        
      )
      
    }
    
  }
  
  return(mfl)
}