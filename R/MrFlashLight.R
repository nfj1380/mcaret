#' mrFlashlight: Wrapper to run multi-response model agnostic interpretable machine learning analyses. 
#'
#' @param yhats A \code{list} generated by \code{mrIMLpredicts}.
#' @param Y A \code{data.frame} containing the response variable data set (species, OTUs, SNPs, etc.).
#' @param X A \code{data.frame} containing the feature data set.
#' @param X1 A \code{data.frame} of additional predictors (optional).
#' @param response \code{character} indicating the type of response: 'single' selects one response, 'multi' selects all responses.
#' @param index \code{numeric} used when \code{response} is 'single' to select which response to create a flashlight object for. The order is the same as in \code{Y}.
#' @param predict_function \code{function} specifying a user-defined prediction function (optional).
#' @param mode \code{character} indicating the type of model: 'classification' or 'regression'.
#'
#' @details This function enables users to utilize interpretable machine learning methods to understand their multi-response and single-response models.
#'
#' @examples 
#' # Single response
#' fl <- mrFlashlight(yhats, X, Y, response = "single", index = 1, mode = "regression")
#' plot(light_performance(fl), fill = "orange") + labs(x = element_blank())
#' plot(light_breakdown(fl, new_obs = cbind(X, Y)[1, ]), by = X, v = Y)
#' int <- light_interaction(fl, pairwise = TRUE)
#'
#' # Multiple response
#' flashlightObj <- mrFlashlight(yhats, X, Y, response = "multi", mode = "regression")
#' @export 


mrFlashlight <- function(yhats, X, X1, Y, response = "multi", index = 1, mode = "regression", predict_function = NULL) {
  
  if (mode == "classification") {
    
    # Prediction function
    if (is.null(predict_function)) {
      pred_fun <- function(m, dat) {
        predict(m, dat[, colnames(X), drop = FALSE], type = "prob")[[".pred_1"]]
      }
    } else {
      pred_fun <- predict_function
    }
    
    # List of metrics
    metrics <- list(
      logloss = MetricsWeighted::logLoss,
      `ROC AUC` = MetricsWeighted::AUC,
      `% Dev Red` = MetricsWeighted::r_squared_bernoulli
    )
    
    # Create explainer
    if (response == "single") {
      mfl <- flashlight(
        model = yhats[[index]]$mod1_k,
        label = colnames(Y)[index],
        data = cbind(Y[index], X),
        y = colnames(Y)[index],
        predict_function = pred_fun,
        metrics = metrics
      )
    } else if (response == "multi") {
      models <- lapply(yhats, `[[`, "mod1_k")
      fl_list <- vector("list", length(yhats))
      for (i in seq_along(fl_list)) {
        fl_list[[i]] <- flashlight(
          model = yhats[[i]]$mod1_k,
          label = colnames(Y)[i],
          y = colnames(Y)[i],
          x = colnames(yhats[[i]]$data)[-1]
        )
      }
      mfl <- multiflashlight(
        fl_list,
        data = cbind(Y, X),
        predict_function = pred_fun,
        metrics = metrics
      )
    }
    
  } else if (mode == "regression") {
    
    # Prediction function
    pred_fun <- function(m, dat) {
      predict(m, dat[, colnames(X), drop = FALSE])[[".pred"]]
    }
    
    # List of metrics
    metrics <- list(
      rmse = MetricsWeighted::rmse,
      `R-squared` = MetricsWeighted::r_squared
    )
    
    # Create explainer
    if (response == "single") {
      mfl <- flashlight(
        model = yhats[[index]]$mod1_k,
        label = colnames(Y)[index],
        data = cbind(Y[index], X),
        y = colnames(Y)[index],
        predict_function = pred_fun,
        metrics = metrics
      )
    } else if (response == "multi") {
      models <- lapply(yhats, `[[`, "mod1_k")
      fl_list <- vector("list", length(yhats))
      for (i in seq_along(fl_list)) {
        fl_list[[i]] <- flashlight(
          model = yhats[[i]]$mod1_k,
          label = colnames(Y)[i],
          y = colnames(Y)[i]
        )
      }
      mfl <- multiflashlight(
        fl_list,
        data = cbind(Y, X),
        predict_function = pred_fun,
        metrics = metrics
      )
    }
    
  } else {
    stop("Invalid mode selected. Please choose either 'classification' or 'regression'.")
  }
  
  return(mfl)
}
