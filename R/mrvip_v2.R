#'Wrapper to estimate model-agnostic variable importance for multi-response models. 
#'@param yhats A \code{list} is the list generated by mrIMLpredicts
#'@param Y  A \code{dataframe} #is the feature dataset
#'@details Calculates variabie importance using based on partial dependencies but could do permutation as well (mor memory intensive).
#' Key imput is the object created by MrIML. Can be plotted with the plot_vi function.
#' @example 
#' VI <- mrVip(yhats, Y=Y)
#' groupCov <- c(rep ("Host_characteristics", 1),rep("Urbanisation", 3), rep("Vegetation", 2), rep("Urbanisation",1), rep("Spatial", 2), 
#' rep('Host_relatedness', 6),rep ("Host_characteristics", 1),rep("Vegetation", 2), rep("Urbanisation",1))  
#' plot_vi(VI=VI,  X=fData,Y=FeaturesnoNA, modelPerf=ModelPerf, groupCov, cutoff= 0.5)
#'@export 

mrVip <- function (yhats, Y){ 
  
  n_response<- length(yhats) ###
  n_features <- sort(names(Y))
  
  modList <- yhats%>% purrr::map(pluck('mod1_k')) #extracts model ###

   im <- lapply(seq(1:n_response), function(i){ #uses monte carlo CV
     
     
     imp <- modList[[2]]%>%  ###
          pull_workflow_fit()
     
     #xgb.importance(model=yhats_xg$fit)
     
  #imp$fit$coefficients[is.na(imp$fit$coefficients)] <- 0#some algorithms will bring back NA coefficents
    # the above doesn't exist for xgb
    # impVI <- vip(imp, num_features=length(Y)) 
     
      impVI <- t(vip::vi(imp, ice=TRUE, feature_names=n_features)) %>% 
        row_to_names(row=1) %>% 
        as.data.frame()
     # impVI[1,] <-as.numeric(impVI )
  
      #sapply(n_features, function (name){
          for (name in n_features) {
            if(!name %in% names(impVI)){
            
             impVI[,name] <- 0 #else just retruning null
            }
     }
   
      
      #this doesnt work for GLMs need another way
      
     #impVI <- vi(imp, ice=TRUE) %>% #this is an update ICE is better when interactions are possible (ie always)
      #impD <- impVI$data %>% 
       #arrange(Variable)%>% 
       #purrr::pluck("Importance")# %>% 
     #names( impVI) <- impVI$variable
     
     # missing <- imp$fit$coefficients[is.na(imp$fit$coefficients)] 
      #missing[is.na(missing)] <- 0
      #impDcombined <- c(impVI, missing)
 })
 
 ImpGlobal <- as.data.frame(do.call(bind_rows, im))
 # ImpGlobal <- as.data.frame(do.call(rbind, im))
   ImpGlobal <-  mutate_all(ImpGlobal, function(x) as.numeric(as.character(x)))#from cbind


}