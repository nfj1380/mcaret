plot_list[[k]] <- plot
}
# Arrange and display the plots in a grid
#p2 <- grid.arrange(grobs = plot_list, plot = FALSE)
p2 <- arrangeGrob(grobs = plot_list, plot = FALSE)
#publication ready plot
combined_plot <- plot_grid(p1, p2, rel_heights = c(1, 0.5), labels = "auto")
#for a taxa of interest
if(!is.null(taxa)){
# Filter the data for the provided taxa
target_data <- vi_df %>% filter(response == taxa)
# Calculate the mean importance of each variable
target_data_avg <- target_data %>%
dplyr::group_by(var) %>%
summarise(mean_imp = mean(sd_value)) %>%
ungroup()
# Get the top variables
top_vars <- head(target_data_avg[order(-target_data_avg$mean_imp), ], local_top_var)
# Filter the data to include only the top variables
target_data_final_df <- target_data %>% filter(var %in% top_vars$var)
# Create the boxplot for the target
p3 <- ggplot(target_data_final_df, aes(x = sd_value, y = reorder(var, sd_value))) +
geom_boxplot() +
theme_bw() +
labs(x = "Importance", y = taxa) +
scale_y_discrete(label = abbreviate) +
theme(
axis.title.x = element_text(size = 8),
axis.title.y = element_text(size = 8)
)
#publication ready plot
combined_plot <- plot_grid(p1, p2,p3, rel_heights = c(1, 0.5), labels = "auto")
}
}
#------------------------------------------------------------------
#Importance PCA plot. Responses with similar importance scores group together
#------------------------------------------------------------------
vi_table_wide <- vi_table %>%
pivot_wider(
id_cols = 'var',
names_from = "response",
values_from = "sd_value") %>%
column_to_rownames('var') %>%
mutate(across(everything(), ~replace(., is.na(.), mean(., na.rm = TRUE))))#or impute with code below
# #X1 will have missing values. This algorithm will impute them with no impact on the pca
# if(!is.null(X1)) {
#
#   ## First the number of components has to be chosen
#   ## (for the reconstruction step)
#
# nb <- estim_ncpPCA(vi_table_wide,ncp.max=4)
#
# ## Multiple Imputation
# vi_table_wide_t <- missMDA::MIPCA( vi_table_wide, ncp = 1)
#
# #get the data
# vi_table_wide <- vi_table_wide_t$res.imputePCA
#
# }
#
# else {
#
#   #keep the data as is otherwise
#   vi_table_wide <- vi_table_wide
# }
#seems like it doesn't make too much difference
a.pca <-  t(vi_table_wide) %>%
prcomp() # do PCA
#-----------------------------------------------------------------------------------------
#outlier detection
uscores <- a.pca$x %>%
as.data.frame()
outL <- apply(uscores, 2, function(x) which( (abs(x - median(x)) / mad(x)) > 6 ))
#-----------------------------------------------------------------------------------------
pca_val <-  a.pca  %>%
tidy(matrix = "eigenvalues")
trans <- t(vi_table_wide)
p3 <- a.pca %>%
augment(trans) %>%
ggplot(aes(.fittedPC1, .fittedPC2)) +
geom_point() +
ggrepel::geom_label_repel(aes(label = rownames(trans)),
box.padding   = 0.35,
point.padding = 0.5,
label.size = 0.1,
segment.color = 'grey50') +
theme_bw()
p4 <- a.pca %>%
tidy(matrix = "eigenvalues") %>%
ggplot(aes(PC, percent)) +
geom_col(fill = "#56B4E9", alpha = 0.8) +
scale_x_continuous(breaks = 1:9) +
scale_y_continuous(
labels = scales::percent_format(),
expand = expansion(mult = c(0, 0.01))
) +
theme_bw()
combined_plot_PCA <- plot_grid( p3, p4, rel_heights = c(1, 0.5), labels = "auto")
return(list(vi_df,vi_table_wide, combined_plot,  combined_plot_PCA, outLiers=outL,  pca_val=pca_val, scores=uscores))
}
#need to make it work for rf - weird error: an't convert from `data$bio_15` <double> to `bio_15` <integer> due to loss of precision.
VI <- mrvip(yhats=yhats_rf ,mrBootstrap_obj = bs_snps, X=X, Y=Y, mode='regression', threshold = 0.1, global_top_var = 10,local_top_var = 5, taxa='CANDIDATE_GI5_9585', ModelPerf=ModelPerf_rf)
#need to make it work for rf - weird error: an't convert from `data$bio_15` <double> to `bio_15` <integer> due to loss of precision.
VI <- mrvip(yhats=yhats_rf ,mrBootstrap_obj = NULL, X=X, Y=Y, mode='regression', threshold = 0.1, global_top_var = 10,local_top_var = 5, taxa='CANDIDATE_GI5_9585', ModelPerf=ModelPerf_rf)
VI[[3]] #Importance plot
VI[[4]] #PCA
#plot_vi(VI=VI,  X=X,Y=Y, modelPerf=ModelPerf,  cutoff= 0.1, mode='regression')
pds <- mrPD_bootstrap(mrBootstrap_obj=bs_snps,
vi_obj=VI, X, Y,
target='CANDIDATE_GI5_9585',
global_top_var=5)
combined_object <- map_dfr(mrBootstrap_obj[[j]], bind_rows_by_name, object_name)
mrBootstrap_obj=bs_snps
vi_obj=VI
target='CANDIDATE_GI5_9585'
global_top_var=5
combined_object <- map_dfr(mrBootstrap_obj[[j]], bind_rows_by_name, object_name)
object_name <- names(complete_df[i])
bind_rows_by_name <- function(list_obj, object_name) {
filtered_list <- list_obj[names(list_obj) %in% object_name]
bind_rows(filtered_list)
}
n_response <- ncol(Y)
complete_df <- cbind(Y, X)
n_data <- ncol(complete_df)
combined_object <- map_dfr(mrBootstrap_obj[[j]], bind_rows_by_name, object_name)
combined_object <- map_dfr(mrBootstrap_obj[[j]], bind_rows_by_name, object_name)
combined_df <- do.call(rbind, combined_list)
combined_list <- list()
combined_df <- do.call(rbind, combined_list)  # Convert the list to a data frame
if (nrow(combined_object) > 0) {
combined_metadata <- data.frame(target = rep(names(Y)[j], nrow(combined_object)))
combined_object <- cbind(combined_object, combined_metadata)
combined_list[[j]] <- combined_object   # Append the combined object to the list
}
}
for (j in 1:n_response) {
combined_object <- map_dfr(mrBootstrap_obj[[j]], bind_rows_by_name, object_name)
if (nrow(combined_object) > 0) {
combined_metadata <- data.frame(target = rep(names(Y)[j], nrow(combined_object)))
combined_object <- cbind(combined_object, combined_metadata)
combined_list[[j]] <- combined_object   # Append the combined object to the list
}
}
combined_df <- do.call(rbind, combined_list)  # Convert the list to a data frame
combined_object <- map_dfr(mrBootstrap_obj[[j]], bind_rows_by_name, object_name)
mrBootstrap_obj[[j]]
bind_rows_by_name <- function(list_obj, object_name) {
filtered_list <- list_obj[names(list_obj) %in% object_name]
bind_rows(filtered_list)
}
object_name <- names(complete_df[i])
object_name
combined_object <- map_dfr(mrBootstrap_obj[[j]], bind_rows_by_name, object_name)
View(combined_object)
object_name
G_target_data_avg <- vi_obj %>%
dplyr::filter(response == {{target}}) %>%
group_by(var) %>%
dplyr::summarise(mean_imp = mean(sd_value)) %>%
arrange(desc(mean_imp))
vi_obj
vi_obj <- vi_obj[[2]]
View(vi_obj)
G_target_data_avg <- vi_obj %>%
dplyr::filter(response == {{target}}) %>%
group_by(var) %>%
dplyr::summarise(mean_imp = mean(sd_value)) %>%
arrange(desc(mean_imp))
View(vi_obj)
vi_obj <- vi_obj[[1]]
vi_obj
vi_obj=VI
vi_obj <- vi_obj[[1]]
vi_obj_test <- do.call(vi_obj, rbind)
vi_obj_test <- do.call(rbind, vi_obj)
View(vi_obj_test)
G_target_data_avg <- vi_obj %>%
dplyr::filter(response == {{target}}) %>%
group_by(var) %>%
dplyr::summarise(mean_imp = mean(sd_value)) %>%
arrange(desc(mean_imp))
G_target_data_avg <- vi_obj_test %>%
dplyr::filter(response == {{target}}) %>%
group_by(var) %>%
dplyr::summarise(mean_imp = mean(sd_value)) %>%
arrange(desc(mean_imp))
#' Bootstrap Partial Dependence plots
#'
#' This function bootstraps model predictions and generates partial dependence plots for each response variable.
#' It also creates a combined plot for the top variables of interest.
#'
#' @param mrBootstrap_obj A list of model bootstraps generated using mrBootstrap function.
#' @param vi_obj Variable Importance data.
#' @param X The predictor data.
#' @param Y The response data.
#' @param target The target variable for generating plots.
#' @param global_top_var The number of top variables to consider (default: 2).
#'
#' @return A list containing the partial dependence plots for each response variable and a combined plot.
#' @export
#'
#' @examples
#' \dontrun{
#'#' # Example usage:
#' #set up analysis
#' Y <- dplyr::select(Bird.parasites, -scale.prop.zos)%>%
#' dplyr::select(sort(names(.)))#response variables eg. SNPs, pathogens, species....
#' X <- dplyr::select(Bird.parasites, scale.prop.zos) # feature set
#' X1 <- Y %>%
#' dplyr::select(sort(names(.)))
#'model_rf <-
#' rand_forest(trees = 100, mode = "classification", mtry = tune(), min_n = tune()) %>% #100 trees are set for brevity. Aim to start with 1000
#' set_engine("randomForest")
#' yhats_rf <- mrIMLpredicts(X=X, Y=Y,
#'X1=X1,'Model=model_rf ,
#'balance_data='no',mode='classification',
#'tune_grid_size=5,seed = sample.int(1e8, 1),'morans=F,
#'prop=0.7, k=5, racing=T) #
#'bs_analysis <- mrBootstrap(yhats=yhats_rf,Y=Y, num_bootstrap = 5)
#'pds <- mrPD_bootstrap(mrBootstrap_obj=bs_malaria, vi_obj=bs_impVIa, X, Y,
#'target='Plas', global_top_var=5)
#'pd_list <- pds[[1]] #data
#'pds[[2]]#plot }
mrPD_bootstrap <- function(mrBootstrap_obj, vi_obj, X, Y, target, global_top_var = 2) {
n_response <- ncol(Y)
complete_df <- cbind(Y, X)
n_data <- ncol(complete_df)
# Internal function to combine objects by name
bind_rows_by_name <- function(list_obj, object_name) {
filtered_list <- list_obj[names(list_obj) %in% object_name]
bind_rows(filtered_list)
}
internal_fit_function <- function(i) {
object_name <- names(complete_df[i])
combined_list <- list()  # Create an empty list to store combined objects
for (j in 1:n_response) {
combined_object <- map_dfr(mrBootstrap_obj[[j]], bind_rows_by_name, object_name)
if (nrow(combined_object) > 0) {
combined_metadata <- data.frame(target = rep(names(Y)[j], nrow(combined_object)))
combined_object <- cbind(combined_object, combined_metadata)
combined_list[[j]] <- combined_object   # Append the combined object to the list
}
}
combined_df <- do.call(rbind, combined_list)  # Convert the list to a data frame
return(combined_df)
}
pd_list <- future_lapply(seq_len(n_data), internal_fit_function, future.seed = TRUE)
plot_list <- list()  # Create an empty list to store individual plots
vi_obj <- vi_obj[[1]]  # Extract VI data #need to check
vi_obj <- do.call(rbind, vi_obj)
G_target_data_avg <- vi_obj %>%
dplyr::filter(response == {{target}}) %>%
group_by(var) %>%
dplyr::summarise(mean_imp = mean(sd_value)) %>%
arrange(desc(mean_imp))
G_top_vars <- head(G_target_data_avg[order(-G_target_data_avg$mean_imp), ], global_top_var)
# Iterate through each pd_list and create individual plots
for (k in seq_along(pd_list)) {
df <- pd_list[[k]] %>%
dplyr::filter(target == {{target}})
if (names(df)[1] %in% G_top_vars$var) {
if (is.factor(df[[1]]) || (all(df[[1]] %in% c(0, 1)))) {
d1 <- df %>%
mutate(class = recode(.[[1]], `0` = "absent", `1` = "present"))
plot <- ggplot(d1, aes(x = class, y = value)) +
geom_boxplot() +
labs(x = names(d1)[1], y = paste(target, "prob", sep = " ")) +
theme_bw()
} else {
d1 <- df %>%
group_by(bootstrap) %>%
rename(class = 1)
plot <- ggplot(d1, aes(x = class, y = value, group = interaction(bootstrap, target)))+
geom_line(alpha = 0.3) +
labs(x =  names(df)[1], y = paste(target, "prob", sep = " ")) +
theme_bw()
}
plot_list[[k]] <- plot  # Add the plot to the list
}
}
plot_list_updated <- plot_list[sapply(plot_list, function(p) any(p$data$value != 0))]
p <- grid.arrange(grobs = plot_list_updated )
# Create combined plot using the order from G_top_vars
#combined_plot <- plot_grid(  plot_list_updated =   plot_list_updated[G_top_vars$var], ncol = 1, rel_heights = rep(1, length(G_top_vars$var)))
combined_plot <- plot_grid(p, ncol = 1, rel_heights = rep(1, length(G_top_vars$var)))
return(list(pd_list, combined_plot ))  # Return both pd_list and combined_plot
}
pds <- mrPD_bootstrap(mrBootstrap_obj=bs_snps,
vi_obj=VI, X, Y,
target='CANDIDATE_GI5_9585',
global_top_var=5)
#' Bootstrap Partial Dependence plots
#'
#' This function bootstraps model predictions and generates partial dependence plots for each response variable.
#' It also creates a combined plot for the top variables of interest.
#'
#' @param mrBootstrap_obj A list of model bootstraps generated using mrBootstrap function.
#' @param vi_obj Variable Importance data.
#' @param X The predictor data.
#' @param Y The response data.
#' @param target The target variable for generating plots.
#' @param global_top_var The number of top variables to consider (default: 2).
#'
#' @return A list containing the partial dependence plots for each response variable and a combined plot.
#' @export
#'
#' @examples
#' \dontrun{
#'#' # Example usage:
#' #set up analysis
#' Y <- dplyr::select(Bird.parasites, -scale.prop.zos)%>%
#' dplyr::select(sort(names(.)))#response variables eg. SNPs, pathogens, species....
#' X <- dplyr::select(Bird.parasites, scale.prop.zos) # feature set
#' X1 <- Y %>%
#' dplyr::select(sort(names(.)))
#'model_rf <-
#' rand_forest(trees = 100, mode = "classification", mtry = tune(), min_n = tune()) %>% #100 trees are set for brevity. Aim to start with 1000
#' set_engine("randomForest")
#' yhats_rf <- mrIMLpredicts(X=X, Y=Y,
#'X1=X1,'Model=model_rf ,
#'balance_data='no',mode='classification',
#'tune_grid_size=5,seed = sample.int(1e8, 1),'morans=F,
#'prop=0.7, k=5, racing=T) #
#'bs_analysis <- mrBootstrap(yhats=yhats_rf,Y=Y, num_bootstrap = 5)
#'pds <- mrPD_bootstrap(mrBootstrap_obj=bs_malaria, vi_obj=bs_impVIa, X, Y,
#'target='Plas', global_top_var=5)
#'pd_list <- pds[[1]] #data
#'pds[[2]]#plot }
mrPD_bootstrap <- function(mrBootstrap_obj, vi_obj, X, Y, target, global_top_var = 2) {
n_response <- ncol(Y)
complete_df <- cbind(Y, X)
n_data <- ncol(complete_df)
# Internal function to combine objects by name
bind_rows_by_name <- function(list_obj, object_name) {
filtered_list <- list_obj[names(list_obj) %in% object_name]
bind_rows(filtered_list)
}
internal_fit_function <- function(i) {
object_name <- names(complete_df[i])
combined_list <- list()  # Create an empty list to store combined objects
for (j in 1:n_response) {
combined_object <- map_dfr(mrBootstrap_obj[[j]], bind_rows_by_name, object_name)
if (nrow(combined_object) > 0) {
combined_metadata <- data.frame(target = rep(names(Y)[j], nrow(combined_object)))
combined_object <- cbind(combined_object, combined_metadata)
combined_list[[j]] <- combined_object   # Append the combined object to the list
}
}
combined_df <- do.call(rbind, combined_list)  # Convert the list to a data frame
return(combined_df)
}
pd_list <- future_lapply(seq_len(n_data), internal_fit_function, future.seed = TRUE)
plot_list <- list()  # Create an empty list to store individual plots
vi_obj <- vi_obj[[1]]  # Extract VI data #need to check
vi_obj <- do.call(rbind, vi_obj)
G_target_data_avg <- vi_obj %>%
dplyr::filter(response == {{target}}) %>%
group_by(var) %>%
dplyr::summarise(mean_imp = mean(sd_value)) %>%
arrange(desc(mean_imp))
print ('here')
G_top_vars <- head(G_target_data_avg[order(-G_target_data_avg$mean_imp), ], global_top_var)
# Iterate through each pd_list and create individual plots
for (k in seq_along(pd_list)) {
df <- pd_list[[k]] %>%
dplyr::filter(target == {{target}})
if (names(df)[1] %in% G_top_vars$var) {
if (is.factor(df[[1]]) || (all(df[[1]] %in% c(0, 1)))) {
d1 <- df %>%
mutate(class = recode(.[[1]], `0` = "absent", `1` = "present"))
plot <- ggplot(d1, aes(x = class, y = value)) +
geom_boxplot() +
labs(x = names(d1)[1], y = paste(target, "prob", sep = " ")) +
theme_bw()
} else {
d1 <- df %>%
group_by(bootstrap) %>%
rename(class = 1)
plot <- ggplot(d1, aes(x = class, y = value, group = interaction(bootstrap, target)))+
geom_line(alpha = 0.3) +
labs(x =  names(df)[1], y = paste(target, "prob", sep = " ")) +
theme_bw()
}
plot_list[[k]] <- plot  # Add the plot to the list
}
}
plot_list_updated <- plot_list[sapply(plot_list, function(p) any(p$data$value != 0))]
p <- grid.arrange(grobs = plot_list_updated )
# Create combined plot using the order from G_top_vars
#combined_plot <- plot_grid(  plot_list_updated =   plot_list_updated[G_top_vars$var], ncol = 1, rel_heights = rep(1, length(G_top_vars$var)))
combined_plot <- plot_grid(p, ncol = 1, rel_heights = rep(1, length(G_top_vars$var)))
return(list(pd_list, combined_plot ))  # Return both pd_list and combined_plot
}
pds <- mrPD_bootstrap(mrBootstrap_obj=bs_snps,
vi_obj=VI, X, Y,
target='CANDIDATE_GI5_9585',
global_top_var=5)
pd_list <- future_lapply(seq_len(n_data), internal_fit_function, future.seed = TRUE)
internal_fit_function <- function(i) {
object_name <- names(complete_df[i])
combined_list <- list()  # Create an empty list to store combined objects
for (j in 1:n_response) {
combined_object <- map_dfr(mrBootstrap_obj[[j]], bind_rows_by_name, object_name)
if (nrow(combined_object) > 0) {
combined_metadata <- data.frame(target = rep(names(Y)[j], nrow(combined_object)))
combined_object <- cbind(combined_object, combined_metadata)
combined_list[[j]] <- combined_object   # Append the combined object to the list
}
}
combined_df <- do.call(rbind, combined_list)  # Convert the list to a data frame
return(combined_df)
}
pd_list <- future_lapply(seq_len(n_data), internal_fit_function, future.seed = TRUE)
df <- pd_list[[k]] %>%
dplyr::filter(target == {{target}})
k=1
df <- pd_list[[k]] %>%
dplyr::filter(target == {{target}})
pd_list[[k]]
n_data
View(pd_list)
remove.packages("mrIML")
devtools::install_github('nfj1380/mrIML')
#' Multiple Response Variable Selection
#'
#' Identify predictors not useful in the prediction of multiple response variables using the Boruta algorithm.
#'
#' @param X Dataframe of predictors. (Optional)
#' @param X1 Dataframe of additional predictors for predicting the response variables. (Optional)
#' @param Y Dataframe with response variables, where column names are the response variable names.
#' @return A list where each element corresponds to a response variable, containing the Boruta result object for that response variable.
#' @examples
#' X <- data.frame(matrix(rnorm(1000), ncol = 10))
#' X1 <- data.frame(matrix(rnorm(100), ncol = 5))
#' Y <- data.frame(response1 = rnorm(100), response2 = rnorm(100))
#' results <- mrVariableSelect(X, X1, Y)
#'
mrPerformancePlot <- function(ModelPerf1 = NULL, ModelPerf2 = NULL,
mod_names=c('combined','Xonly_model'), mode='classification' ) {
m1 <- ModelPerf1[[1]]
m2 <- ModelPerf2[[1]]
d_length <- nrow(m1) #has to be the same
if (mode=='classification'){
m1$mcc <- as.numeric(m1$mcc) #extract mcc
m1 <- m1 %>%
dplyr::rename(metric = mcc)
model1_df <- m1 %>% tibble(model_type = rep(mod_names[1], d_length)) %>%
replace_na(list(metric = 0)) #NAs happen when there is no variance in the model predictions (i.e.all 0s), for these make NAs=0
m2$mcc <- as.numeric(m2$mcc)
model2_df <- m2 %>% tibble(model_type = rep(mod_names[2], d_length)) %>%
dplyr::rename(metric=mcc) %>%
replace_na(list(metric = 0))
} else {
model1_df <- m1 %>% tibble(model_type = rep(mod_names[1], d_length)) %>%
dplyr::rename(metric=rmse)
model2_df <- m2 %>% tibble(model_type = rep(mod_names[2], d_length)) %>%
dplyr::rename(metric=rmse)
}
model_compare_df <- bind_rows(model1_df , model2_df )
#detect outliers function
findoutlier <- function(x) {
return(x < quantile(x, .25) - 1.5*IQR(x) | x > quantile(x, .75) + 1.5*IQR(x))
}
#create data frame
plot_df <- model_compare_df %>%
group_by(model_name) %>%
mutate(outlier = ifelse(findoutlier(metric), metric, NA))
if(mode=='classification') {
p1 <- ggplot(plot_df, aes(x=model_name, y=metric)) +
geom_boxplot() +
geom_text(aes(label=outlier), na.rm=TRUE, hjust=-.5) +
theme_bw()+
labs(y='MCC')
} else {
p1 <- ggplot(plot_df, aes(x=model_name, y=metric)) +
geom_boxplot() +
geom_text(aes(label=outlier), na.rm=TRUE, hjust=-.5) +
theme_bw()+
labs(y='RMSE')
}
#individual taxa
wide_df <- plot_df %>%
select(response, model_name, metric, outlier) %>%
pivot_wider(names_from = model_name, values_from = metric)
# Calculate differences from the first model (combined)
wide_df <- wide_df %>%
mutate( diff_mod1_2 = .[[4]] - .[[3]])
# Reshape back to long format for plotting
long_df <- wide_df %>%
pivot_longer(cols = starts_with("diff_"), names_to = "comparison", values_to = "difference")
# Plot the differences
if(mode=='classification'){
p2 <- ggplot(long_df, aes(x=reorder(response, difference, decreasing =T), y=  difference))+
geom_bar(stat = "identity") +
coord_flip() +
labs(x = "Response", y = "Difference in MCC", title = paste(mod_names[2]," vs ",paste(mod_names[1])) ) +
theme_bw()
} else {
p2 <- ggplot(long_df, aes(x=reorder(response, difference, decreasing =T), y=  difference))+
geom_bar(stat = "identity") +
coord_flip() +
labs(x = "Response", y = "Difference in RMSE", title = paste(mod_names[2]," vs ",paste(mod_names[1])) ) +
theme_bw()
}
return(list(p1, p2, wide_df))
}
debugSource("~/MrIML/mrIML/R/mrPerformancePlot.R")
?generateDataSe
?generateDataSet
??generateDataSe
??ts.plot
