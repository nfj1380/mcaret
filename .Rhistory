#Install the most uptodate version from github
#if (!requireNamespace("devtools", quietly = TRUE))
# install.packages("devtools")
#devtools:: install_github('nfj1380/mrIML')
library(mrIML)
#other package we need:
library(vip); library(tidymodels); library(randomForest);  library(caret); library(gbm);
library(tidyverse);library(parallel); library(doParallel); library(themis); library(viridis); library(janitor); library(hrbrthemes); library(xgboost); library(vegan);library(flashlight);
library(ggrepel)
#library(LEA)
# read in data file with minor allele freqs & env/space variables
gfData; str(gfData)
envGF <- gfData[,3:13] # get climate & MEM variables
Y <- envGF #for simplicity
# build individual SNP datasets
SNPs_ref <- gfData[,grep("REFERENCE",colnames(gfData))] # reference
GI5 <- gfData[,grep("GI5",colnames(gfData))] # GIGANTEA-5 (GI5)
X <- GI5 #for this example we are going to focus on the adaptive SNPs in the GI5 region.
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
gfData; str(gfData)
str()
str
?str\
?str
pkgdown::build_site()
build_home()
build_news()
pkgdown::build_site()
pkgdown::build_site()
library(pkgdown)
pkgdown::build_site()
build_news()
#init_site()
sink()
#init_site()
sink()
build_news()
pkgdown::build_site()
library(pkgdown)
#init_site()
sink()
pkgdown::build_site()
library(pkgdown)
pkgdown::build_site()
usethis::use_github_action("pkgdown")
usethis::use_github_action("pkgdown")
pkgdown::build_site()
getwd()
build_news()
library(pkgdown)
build_home()
pkgdown::build_site()
library(pkgdown)
library(pkgdown)
pkgdown::build_site()
<<<<<<< HEAD
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
library(mrIML)
remove.packages("mrIML", lib="~/R/win-library/3.6")
devtools::install_github('nfj1380/mrIML')
install.packages("xgboost")
pkgdown::build_site()
library(mrIML)
library(mrIML)
model1 <-
rand_forest(trees = 100, mode = "classification") %>% #100 trees are set for brevity
set_engine("ranger", importance = c("impurity","impurity_corrected")) %>%# select the engine/package that underlies the model
set_mode("classification")# choose either the continuous "regression" or binary "classification" mode
library(mrIML)
#other package needed:
library(vip); library(tidymodels); library(randomForest);  library(caret); library(gbm);
library(tidyverse);library(parallel); library(doParallel); library(themis); library(viridis);
library(janitor); library(hrbrthemes); library(xgboost); library(vegan);library(flashlight);
library(mrIML)
#other package needed:
library(vip); library(tidymodels); library(randomForest);  library(caret); library(gbm);
library(tidyverse);library(parallel); library(doParallel); library(themis); library(viridis);
library(janitor); library(hrbrthemes); library(xgboost);library(flashlight);
library(ggrepel); library(parsnip);library(rsample); library(workflows)
VI <- mrVip(yhats, Y=Y)
detach("package:mrIML", unload = TRUE)
library(mrIML)
VI <- mrVip(yhats, Y=Y)
# Define set of features
FeaturesnoNA<-Features[complete.cases(Features), ]
Y <- FeaturesnoNA #for simplicity
# Define set the outcomes of interst
fData <- filterRareCommon (Responsedata, lower=0.4, higher=0.7)
X <- fData #
yhats <- mrIMLpredicts(X=X,Y=Y, model1=model1, balance_data='no', mod='classification', parallel = TRUE)
model1 <-
rand_forest(trees = 100, mode = "classification") %>% #100 trees are set for brevity
set_engine("ranger", importance = c("impurity","impurity_corrected")) %>%# select the engine/package that underlies the model
set_mode("classification")# choose either the continuous "regression" or binary "classification" mode
data <- gfData[1:20]
head(data)
# Define set of features
FeaturesnoNA<-Features[complete.cases(Features), ]
Y <- FeaturesnoNA #for simplicity
# Define set the outcomes of interst
fData <- filterRareCommon (Responsedata, lower=0.4, higher=0.7)
X <- fData #
yhats <- mrIMLpredicts(X=X,Y=Y, model1=model1, balance_data='no', mod='classification', parallel = TRUE)
#save(yhats, file='logreg_model')
ModelPerf <- mrIMLperformance(yhats, model1, X=X) #
ModelPerf[[2]]
VI <- mrVip(yhats, Y=Y)
plot_vi(VI=VI,  X=X,Y=Y, modelPerf=ModelPerf, cutoff= 0, plot.pca='yes') #the cutoff reduces the number of individual models printed in the second plot.
pkgdown::build_site()
20216+4198
25000-24414
13*30
30+36+4+4
74*13
20216+4198+586
100*40
4000*4
16000*12
20*100
2000*4
devtools::session_info()
360/5
25+45+80
25+45+80+50+50
25+45+80+50+80
35+45+80+50+80
35+75+80+50+80
35+75+80+60+80
35+75+80+70+80
45+75+80+70+80
45+75+85+70+80
45+75+85+75+80
30/5
30/54
30/4
30/2
30/3
30/4
6*5
=======
>>>>>>> dbccd43166391d87671ae0def0ce3a4cc8e88027
<<<<<<< HEAD
library(pkgdown)
pkgdown::build_site()
build_news()
build_home()
pkgdown::build_site()
=======
>>>>>>> abce6e7093966e7d10b493afb89473eb098516d9
>>>>>>> 03c98ad2a032d73ac4f16dd64c964759fa57d22b
pkgdown::build_site()
library(pkgdown)
pkgdown::build_site()
devtools::check()
devtools::document()
devtools::check()
library(knitr)
knitr::opts_chunk$set(echo = TRUE)
options(rmarkdown.html_vignette.check_title = FALSE)
library(mrIML)
#other packages needed
library(ggsci); library(vip); library(mrIML); library(imputeTS); library(mice); library(tidymodels); library(pdp); library(randomForest); library(caret); library(missForest); library(gbm); library(tidyverse); library(doParallel); library(themis); library(viridis); library(janitor); library(hrbrthemes); library(MRFcov); library(xgboost); library(vegan); library(ggrepel); library(LEA); library(ape); library(plyr); library(flashlight); library(devtools); library(VIM); library(breakDown); library(iml); library(ggpubr); library(DALEX); library(cowplot); library(ggtext); library(dplyr)
set.seed(130) #set the seed to ensure consistency
#revalue the outcome
colnames(data)[1] <- "Class"
getwd()
devtools::check()
devtools::document()
set.seed(130) #set the seed to ensure consistency
#revalue the outcome
colnames(data)[1] <- "Class"
data<-read.csv("./data/biosecurity_vignette_data.csv")
set.seed(130) #set the seed to ensure consistency
data<-read.csv("./data/biosecurity_vignette_data.csv")
getwd()
data<-read.csv("/data/biosecurity_vignette_data.csv")
data <- read_csv("data/biosecurity_vignette_data.csv")
library(readr)
biosecurity_vignette_data <- read_csv("data/biosecurity_vignette_data.csv")
View(biosecurity_vignette_data)
data<-read_csv("data/biosecurity_vignette_data.csv")
data<-read_csv("/data/biosecurity_vignette_data.csv")
data<-read_csv("./data/biosecurity_vignette_data.csv")
getwd()
data<-read_csv("data/biosecurity_vignette_data.csv")
set.seed(130) #set the seed to ensure consistency
biosecurity_vignette_data <- read_csv("data/biosecurity_vignette_data.csv")
library(mrIML)
#other packages needed
library(ggsci); library(vip); library(mrIML); library(imputeTS); library(mice); library(tidymodels); library(pdp); library(randomForest); library(caret); library(missForest); library(gbm); library(tidyverse); library(doParallel); library(themis); library(viridis); library(janitor); library(hrbrthemes); library(MRFcov); library(xgboost); library(vegan); library(ggrepel); library(LEA); library(ape); library(plyr); library(flashlight); library(devtools); library(VIM); library(breakDown); library(iml); library(ggpubr); library(DALEX); library(cowplot); library(ggtext); library(dplyr)
biosecurity_vignette_data <- read_csv("data/biosecurity_vignette_data.csv")
load_all()
set.seed(130) #set the seed to ensure consistency
#revalue the outcome
colnames(data)[1] <- "Class"
data()
save(biosecurity_vignette_data , file="biosecurity_vignette_data.RData")
set.seed(130) #set the seed to ensure consistency
data()
#revalue the outcome
colnames(data)[1] <- "Class"
data()
set.seed(130) #set the seed to ensure consistency
data
#revalue the outcome
colnames(data)[1] <- "Class"
load("Q:/My Drive/GitHub/mrIML_1.0.1/data/biosecurity_vignette_data.RData")
set.seed(130) #set the seed to ensure consistency
load("Q:/My Drive/GitHub/mrIML_1.0.1/data/biosecurity_vignette_data.RData")
#revalue the outcome
colnames(data)[1] <- "Class"
set.seed(130) #set the seed to ensure consistency
data<-biosecurity_vignette_data
#revalue the outcome
colnames(data)[1] <- "Class"
data<-data%>%
mutate(Class = revalue(Class,
c("Negative"="0", "Positive"="1")))
data$Class<-as.numeric(as.character(data$Class))
#split predictor variables and outcome
X <- as.data.frame(data %>% select(1))
Y <- data %>% select(-c(1, 44, 45)) #remove class, group and ID
model1 <- #model used to generate yhat
#specify that the model is a random forest
rand_forest(trees = 100, mtry = tune(), min_n = tune(), mode = "classification") %>%
#select the engine/package that underlies the model
set_engine("ranger", importance = c("impurity","impurity_corrected")) %>%
#must be set to classification for classification problems
set_mode("classification")
set.seed(130) #set the seed to ensure consistency
data<-biosecurity_vignette_data
#revalue the outcome
colnames(data)[1] <- "Class"
data<-data%>%
mutate(Class = revalue(Class,
c("Negative"="0", "Positive"="1")))
data$Class<-as.numeric(as.character(data$Class))
#split predictor variables and outcome
X <- as.data.frame(data %>% select(1))
Y <- data %>% select(-c(1, 44, 45)) #remove class, group and ID
model1 <- #model used to generate yhat
#specify that the model is a random forest
rand_forest(trees = 100, mtry = tune(), min_n = tune(), mode = "classification") %>%
#select the engine/package that underlies the model
set_engine("ranger", importance = c("impurity","impurity_corrected")) %>%
#must be set to classification for classification problems
set_mode("classification")
yhats <- mrIMLpredicts(X=X, #response data
Y=Y, #features/predictors
model1=model1, #specify your model
balance_data='no', #chose how to balance your data
model='classification', #chose your mode (classification versus regression)
parallel = FALSE, #do you want to run the model in parallel?
seed = 120) #set seed
ModelPerf <- mrIMLperformance(yhats, model1, X=X, model='classification')
ModelPerf[[1]] #predictive performance for individual responses
ModelPerf[[2]]#overall predictive performance. r2 for regression and MCC for classification
#calculate variable importance
VI <- mrVip(yhats, Y=Y)
#plot cumulative variable importance
plot_vi(VI=VI,  X=X,Y=Y,
modelPerf=ModelPerf,
cutoff= 0.6,
plot.pca='no') #Follow instructions in console
#create a flashlight object
fl <- mrFlashlight(yhats, X, Y,
response = "single",
index=1,
model='classification')
#plot partial dependence profiles
plot(light_profile(fl, v = "Gen_replace", stats = "quartiles"))
Y
#create a flashlight object
fl <- mrFlashlight(yhats, X, Y,
response = "single",
index=1,
model='classification')
#plot partial dependence profiles
plot(light_profile(fl, v = "Wf_3_rad", stats = "quartiles"))
str(data)
#create a flashlight object
fl <- mrFlashlight(yhats, X, Y,
response = "single",
index=1,
model='classification')
#plot partial dependence profiles
plot(light_profile(fl, v = "Swine_3_rad", stats = "quartiles"))
#create a flashlight object
fl <- mrFlashlight(yhats, X, Y,
response = "single",
index=1,
model='classification')
#plot partial dependence profiles
plot(light_profile(fl, v = "Swine_3_rad"))
#apply the trained model to the entire data set to provide risk of predicted outbreak
fit_bio <- pull_workflow_fit(yhats[[1]]$mod1_k)
preds_pos <- predict(fit_bio, data, "prob")
data$predicted <- preds_pos$.pred_1
#process data ready for the function
data$Class <- as.factor(data$Class)
data<-data%>%
mutate(Class = revalue(Class,
c("1" = "Positive", "0" = "Negative")))
data$Class <- relevel(data$Class, "Positive")
#plot among group comparison of predicted risk
mrBenchmark(dat = "data", outcome = "Class", y = "predicted", group = "Group", type = "external")
#plot within group comparison of predicted risk
mrBenchmark(dat = "data", outcome = "Class", y = "predicted", group = "Group", label_by = "ID", type = "internal")
#Use this function to implement the local explainer
mrLocalExplainer(dat = Y, model_dat = yhats, outcome = data$Class)
#Use this function to implement the local explainer
mrLocalExplainer(dat = Y, model_dat = yhats, outcome = data$Class)
library(mrIML)
#other packages needed
library(ggsci); library(vip); library(mrIML); library(imputeTS); library(mice); library(tidymodels); library(pdp); library(randomForest); library(caret); library(missForest); library(gbm); library(tidyverse); library(doParallel); library(themis); library(viridis); library(janitor); library(hrbrthemes); library(MRFcov); library(xgboost); library(vegan); library(ggrepel); library(LEA); library(ape); library(plyr); library(flashlight); library(devtools); library(VIM); library(breakDown); library(iml); library(ggpubr); library(DALEX); library(cowplot); library(ggtext); library(dplyr)
set.seed(130) #set the seed to ensure consistency
data<-biosecurity_vignette_data
#revalue the outcome
colnames(data)[1] <- "Class"
data<-data%>%
mutate(Class = revalue(Class,
c("Negative"="0", "Positive"="1")))
data$Class<-as.numeric(as.character(data$Class))
#split predictor variables and outcome
X <- as.data.frame(data %>% select(1))
Y <- data %>% select(-c(1, 44, 45)) #remove class, group and ID
model1 <- #model used to generate yhat
#specify that the model is a random forest
rand_forest(trees = 100, mtry = tune(), min_n = tune(), mode = "classification") %>%
#select the engine/package that underlies the model
set_engine("ranger", importance = c("impurity","impurity_corrected")) %>%
#must be set to classification for classification problems
set_mode("classification")
build_articles()
set.seed(130) #set the seed to ensure consistency
data<-biosecurity_vignette_data
devtools::document()
devtools::load_all()
set.seed(130) #set the seed to ensure consistency
data<-biosecurity_vignette_data
devtools::build_vignettes()
load("Q:/My Drive/GitHub/mrIML_1.0.1/data/biosecurity_vignette_data.RData")
set.seed(130) #set the seed to ensure consistency
load("Q:/My Drive/GitHub/mrIML_1.0.1/data/biosecurity_vignette_data.RData")
data<-biosecurity_vignette_data
#revalue the outcome
colnames(data)[1] <- "Class"
data<-data%>%
mutate(Class = revalue(Class,
c("Negative"="0", "Positive"="1")))
data$Class<-as.numeric(as.character(data$Class))
#split predictor variables and outcome
X <- as.data.frame(data %>% select(1))
Y <- data %>% select(-c(1, 44, 45)) #remove class, group and ID
model1 <- #model used to generate yhat
#specify that the model is a random forest
rand_forest(trees = 100, mtry = tune(), min_n = tune(), mode = "classification") %>%
#select the engine/package that underlies the model
set_engine("ranger", importance = c("impurity","impurity_corrected")) %>%
#must be set to classification for classification problems
set_mode("classification")
#calculate variable importance
VI <- mrVip(yhats, Y=Y)
set.seed(130) #set the seed to ensure consistency
load("Q:/My Drive/GitHub/mrIML_1.0.1/data/biosecurity_vignette_data.RData")
data<-biosecurity_vignette_data
#revalue the outcome
colnames(data)[1] <- "Class"
data<-data%>%
mutate(Class = revalue(Class,
c("Negative"="0", "Positive"="1")))
data$Class<-as.numeric(as.character(data$Class))
#split predictor variables and outcome
X <- as.data.frame(data %>% select(1))
Y <- data %>% select(-c(1, 44, 45)) #remove class, group and ID
model1 <- #model used to generate yhat
#specify that the model is a random forest
rand_forest(trees = 100, mtry = tune(), min_n = tune(), mode = "classification") %>%
#select the engine/package that underlies the model
set_engine("ranger", importance = c("impurity","impurity_corrected")) %>%
#must be set to classification for classification problems
set_mode("classification")
yhats <- mrIMLpredicts(X=X, #response data
Y=Y, #features/predictors
model1=model1, #specify your model
balance_data='no', #chose how to balance your data
model='classification', #chose your mode (classification versus regression)
parallel = FALSE, #do you want to run the model in parallel?
seed = 120) #set seed
build_articles()
devtools::document()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
#make sure you have installed devtools previously.
#Install the most uptodate version from github
#if (!requireNamespace("devtools", quietly = TRUE))
# install.packages("devtools")
#devtools:: install_github('nfj1380/mrIML')
library(mrIML)
#other package we need:
library(vip); library(tidymodels); library(randomForest);  library(caret); library(gbm);
library(tidyverse);library(parallel); library(doParallel); library(themis); library(viridis); library(janitor); library(hrbrthemes); library(xgboost); library(vegan);library(flashlight);
library(ggrepel); library(ranger)
#library(LEA)
# read in data file with minor allele freqs & env/space variables
gfData; str(gfData)
library(LEA)
devtools::check()
devtools::check()
devtools::check()
devtools::check()
?factor
devtools::document()
devtools::check()
devtools::document()
devtools::check()
build_articles()
pkgdown::build_site()
pkgdown::build_site()
library(pkgdown)
pkgdown::build_site()
devtools::document()
devtools::check()
library(knitr)
knitr::opts_chunk$set(echo = TRUE)
options(rmarkdown.html_vignette.check_title = FALSE)
library(mrIML)
#other packages needed
library(parsnip); library(mrIML); library(tidymodels); library(workflows); library(tidyverse); library(flashlight); library(devtools); library(DALEX); library(plyr); library(vip); library(ggsci); library(ggrepel)
set.seed(130) #set the seed to ensure consistency
load("Q:/My Drive/GitHub/mrIML_1.0.1/data/biosecurity_vignette_data.RData")
data<-biosecurity_vignette_data
#revalue the outcome
colnames(data)[1] <- "Class"
data<-data%>%
mutate(Class = revalue(Class,
c("Negative"="0", "Positive"="1")))
data$Class<-as.numeric(as.character(data$Class))
#split predictor variables and outcome
X <- as.data.frame(data %>% select(1))
Y <- data %>% select(-c(1, 44, 45)) #remove class, group and ID
model1 <- #model used to generate yhat
#specify that the model is a random forest
rand_forest(trees = 100, mtry = tune(), min_n = tune(), mode = "classification") %>%
#select the engine/package that underlies the model
set_engine("ranger", importance = c("impurity","impurity_corrected")) %>%
#must be set to classification for classification problems
set_mode("classification")
yhats <- mrIMLpredicts(X=X, #response data
Y=Y, #features/predictors
model1=model1, #specify your model
balance_data='no', #chose how to balance your data
model='classification', #chose your mode (classification versus regression)
parallel = FALSE, #do you want to run the model in parallel?
seed = 120) #set seed
ModelPerf <- mrIMLperformance(yhats, model1, X=X, model='classification')
ModelPerf[[1]] #predictive performance for individual responses
ModelPerf[[2]]#overall predictive performance. r2 for regression and MCC for classification
#calculate variable importance
VI <- mrVip(yhats, Y=Y)
#plot cumulative variable importance
plot_vi_biosecurity(VI=VI,  X=X,Y=Y,
modelPerf=ModelPerf,
cutoff= 0.6,
plot.pca='no') #Follow instructions in console
#create a flashlight object
fl <- mrFlashlight(yhats, X, Y,
response = "single",
index=1,
model='classification')
#plot partial dependence profiles
plot(light_profile(fl, v = "Swine_3_rad"))
#apply the trained model to the entire data set to provide risk of predicted outbreak
fit_bio <- pull_workflow_fit(yhats[[1]]$mod1_k)
preds_pos <- predict(fit_bio, data, "prob")
data$predicted <- preds_pos$.pred_1
#process data ready for the function
data$Class <- as.factor(data$Class)
data<-data%>%
mutate(Class = revalue(Class,
c("1" = "Positive", "0" = "Negative")))
data$Class <- relevel(data$Class, "Positive")
#plot among group comparison of predicted risk
mrBenchmark(dat = "data", outcome = "Class", y = "predicted", group = "Group", type = "external")
#Use this function to implement the local explainer
mrLocalExplainer(dat = Y, model_dat = yhats, outcome = data$Class)
library(mrIML)
#other packages needed
library(parsnip); library(mrIML); library(tidymodels); library(workflows); library(tidyverse); library(flashlight); library(devtools); library(DALEX); library(plyr); library(vip); library(ggsci); library(ggrepel);library(breakDown)
#Use this function to implement the local explainer
mrLocalExplainer(dat = Y, model_dat = yhats, outcome = data$Class)
library(mrIML)
remove.packages("mrIML", lib="~/R/win-library/3.6")
devtools::install_github('nfj1380/mrIML')
library(mrIML)
#other packages needed
library(parsnip); library(mrIML); library(tidymodels); library(workflows); library(tidyverse); library(flashlight); library(devtools); library(DALEX); library(plyr); library(vip); library(ggsci); library(ggrepel);library(breakDown)
#Use this function to implement the local explainer
mrLocalExplainer(dat = Y, model_dat = yhats, outcome = data$Class)
#Use this function to implement the local explainer
mrLocalExplainer(dat = Y, model_dat = yhats, outcome = data$Class)
