if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
#make sure you have installed devtools previously.
#Install the most uptodate version from github
#if (!requireNamespace("devtools", quietly = TRUE))
# install.packages("devtools")
#   devtools:: install_github('nfj1380/mrIML')
library(mrIML)
#other package we need:
library(vip); library(tidymodels); library(randomForest);  library(caret); library(gbm);
library(tidyverse);library(parallel); library(doParallel); library(themis); library(viridis);
library(janitor); library(hrbrthemes); library(xgboost); library(vegan);library(flashlight);
library(ggrepel); library(parsnip);library(rsample); library(workflows)
#load SNP data
#Responsedata)
#if you have a plink dataset you can load it in to our pipeline with the following:
#snps <- readSnpsPed("snp.ped", "snp.map") #NAs in data and interpolated as the mode.
#landscape and host features (or predictors). Note that samples must be rows.
str(Features)
# # remove NAs from the feature/predictor data.
FeaturesnoNA<-Features[complete.cases(Features), ]
Y <- FeaturesnoNA #for simplicity
#for more efficient testing for interactions (more variables more interacting pairs)
Y <- FeaturesnoNA[c(1:3)] #three features only
pkgdown::build_site()
fl <- mrFlashlight(yhats, X, Y, response = "multi", index=1, model='classification') #index pointing to the SNP of interest (i.e. the first column)
pkgdown::build_site()
detach("package:flashlight", unload = TRUE)
library(flashlight)
knitr::opts_chunk$set(echo = TRUE)
#make sure you have installed devtools previously.
#Install the most uptodate version from github
#if (!requireNamespace("devtools", quietly = TRUE))
# install.packages("devtools")
#   devtools:: install_github('nfj1380/mrIML')
library(mrIML)
#other package we need:
library(vip); library(tidymodels); library(randomForest);  library(caret); library(gbm);
library(tidyverse);library(parallel); library(doParallel); library(themis); library(viridis);
library(janitor); library(hrbrthemes); library(xgboost); library(vegan);library(flashlight);
library(ggrepel); library(parsnip);library(rsample); library(workflows)
#load SNP data
#Responsedata)
#if you have a plink dataset you can load it in to our pipeline with the following:
#snps <- readSnpsPed("snp.ped", "snp.map") #NAs in data and interpolated as the mode.
#landscape and host features (or predictors). Note that samples must be rows.
str(Features)
# # remove NAs from the feature/predictor data.
FeaturesnoNA<-Features[complete.cases(Features), ]
Y <- FeaturesnoNA #for simplicity
#for more efficient testing for interactions (more variables more interacting pairs)
Y <- FeaturesnoNA[c(1:3)] #three features only
#Optional: Filter rare/common SNPs or species. Retaining minor allele frequencies >0.1 and removing common alleles (occur>0.9)
fData <- filterRareCommon (Responsedata, lower=0.4, higher=0.7)
X <- fData #for simplicity when comparing
X <- X[,-9] #for simplicity when comparing
#another option at this stage is to filter response that are strongly correlated with each other.
#df2 <- cor(X) #find correlations
#hc <-  findCorrelation(df2, cutoff=0.5) # put any value as a "cutoff".
#hc <-  sort(hc)
#X <-  X[,-c(hc)] #
#R <- resist_components(filename = 'location of pairwise matrices', p_val=0.01 ) # p values are used here to filter resistance components that aren't correlated with th original pairwise matrix.
#Y <- cbind(R,Y)
model1 <-
rand_forest(trees = 100, mode = "classification") %>% #100 trees are set for brevity
# select the engine/package that underlies the model
set_engine("ranger", importance = c("impurity","impurity_corrected")) %>%
# choose either the continuous regression or binary classification mode
set_mode("classification")
model1 <-
rand_forest(trees = 100, mode = "classification") %>% #100 trees are set for brevity
# select the engine/package that underlies the model
set_engine("ranger", importance = c("impurity","impurity_corrected")) %>%
# choose either the continuous regression or binary classification mode
set_mode("classification")
yhats <- mrIMLpredicts(X=X,Y=Y, model1=model1, balance_data='no', mod='classification', parallel = TRUE) ## in MrTidymodels. Balanced data= up updamples and down downsampled to create a balanced set
# save the model
#save(yhats, file='rf_model')
VI <- mrVip(yhats, Y=Y)
#plot_vi(VI=VI,X=X, Y=Y, modelPerf=ModelPerf, cutoff= 0, plot.pca='yes', model='classification') #the cutoff reduces the number of individual models printed in the second plot.
groupCov <- c(rep ("Host_characteristics", 1),rep("Urbanisation", 3), rep("Vegetation", 2), rep("Urbanisation",1), rep("Spatial", 2), rep('Host_relatedness', 6),rep ("Host_characteristics", 1),rep("Vegetation", 2), rep("Urbanisation",1))
#plot_vi(VI=VI,  X=X,Y=Y, modelPerf=ModelPerf, groupCov=groupCov, cutoff= 0.5, plot.pca='no')
source(("C:/Users/gmachad/Desktop/mrIML_package/R/mrFlashlight.R"))
#source(("C:/Users/gmachad/Desktop/mrIML_package/R/mrFlashlight.R"))
#source(("C:/Users/gmachad/Desktop/mrIML_package/R/mrProfileplots.R"))
fl <- mrFlashlight(yhats, X, Y, response = "multi", index=1, model='classification') #index pointing to the SNP of interest (i.e. the first column)
plot(light_performance(fl), fill = "orange", rotate_x = TRUE) +
labs(x = element_blank()) +
theme(axis.text.x = element_text(size = 8))
flashlightObj <- mrFlashlight(yhats, X, Y, response = "multi", model='classification')
#plot prediction scatter for all responses. Gets busy with
plot(light_scatter(flashlightObj, v = "Forest", type = "predicted"))
#plots everything on one plot (partial dependency, ALE, scatter)
plot(light_effects(flashlightObj, v = "Grassland"), use = "all")
#profileData_pd <- light_profile(flashlightObj,  v = "Grassland")
#mrProfileplot(profileData_pd , sdthresh =0.05) #sdthresh removes responses from the first plot that do not vary with the feature
profileData_ale <- light_profile(flashlightObj, v = "Grassland", type = "ale") #acumulated local effects
mrProfileplot(profileData_ale , sdthresh =0.01)
#the second plot is the cumulative turnover function
install.packages("pdp")
pkgdown::build_site()
#Load required libraries
library(ggplot2)
library(deSolve)
library(reshape2)
initial_state_values=c(S=999999,I=1,R=0)
parameters=c(gamma=0.20,beta=0.5)
time=seq(from=1,to=100,by=1)
sir_model <- function(time,state,parameters){
with(as.list(c(state,parameters)),{
N=S+I+R
lambda=beta*(I/N)
dS=-lambda*S
dI=lambda*S-gamma*I
dR=gamma*I
return(list(c(dS,dI,dR)))
}
)
}
#Solving the differential equations
output<-as.data.frame(ode(y=initial_state_values,func = sir_model,parms=parameters,times = time))
#Load required libraries
library(ggplot2)
library(deSolve)
install.packages("deSolve")
#Load required libraries
library(ggplot2)
library(deSolve)
library(reshape2)
# Model inputs
initial_state_values=c(S=999999,I=1,R=0)
parameters=c(gamma=0.20,beta=0.5)
# Time points
time=seq(from=1,to=100,by=1)
# SIR model function
sir_model <- function(time,state,parameters){
with(as.list(c(state,parameters)),{
N=S+I+R
lambda=beta*(I/N)
dS=-lambda*S
dI=lambda*S-gamma*I
dR=gamma*I
return(list(c(dS,dI,dR)))
}
)
}
#Solving the differential equations
output<-as.data.frame(ode(y=initial_state_values,func = sir_model,parms=parameters,times = time))
out_long=melt(output,id="time")
# To plot the proportion of susceptible, infected and recovered individuals over time
ggplot(data = out_long,
aes(x = time, y = value/1000000, colour = variable, group = variable)) +
geom_line() +xlab("Time (days)")+ylab("Proportion of the population")+
scale_color_discrete(name="State")
library(ggplot2)
library(deSolve)
library(reshape2)
# Model inputs
initial_state_values=c(S=999999,I=1,R=0)
parameters=c(gamma=0.2*365,beta=0.4*365,mu=1/70,b=1/70)
# Time points
time=seq(from=1,to=400,by=1/365)
# SIR model function
sir_model2 <- function(time,state,parameters){
with(as.list(c(state,parameters)),{
N=S+I+R
lambda=beta*(I/N)
dS=-lambda*S-mu*S+b*N
dI=lambda*S-gamma*I-mu*I
dR=gamma*I-mu*R
return(list(c(dS,dI,dR)))
}
)
}
# Solving the differential equations:
output<-as.data.frame(ode(y=initial_state_values,func = sir_model2,parms=parameters,times = time))
out_long=melt(output,id="time")
#Plotting the prevelance over time
ggplot(data = out_long,
aes(x = time, y = value/1000000, colour = variable, group = variable)) +
geom_line() +
xlab("Time (years)")+
ylab("Prevalence") + scale_color_discrete(name="State")
#Loading libraries
library(ggplot2)
library(deSolve)
library(reshape2)
# Model inputs
initial_state_values=c(S=0.60*999999,I=1,R=0.40*999999)
parameters=c(gamma=0.1,beta=0.4)
# Time points
time=seq(from=1,to=3*365,by=1)
#SIR Model function
sir_model3 <- function(time,state,parameters){
with(as.list(c(state,parameters)),{
N=S+I+R
lambda=beta*(I/N)
dS=-lambda*S
dI=lambda*S-gamma*I
dR=gamma*I
return(list(c(dS,dI,dR)))
}
)
}
# Solving the differential equations:
output<-as.data.frame(ode(y=initial_state_values,func = sir_model3,parms=parameters,times = time))
out_long=melt(output,id="time")
#Plot of prevalance
ggplot(data = out_long,
aes(x = time, y = value/1000000, colour = variable, group = variable)) +
geom_line() +
xlab("Time (days)")+
ylab("Prevalance") +scale_color_discrete(name="State")
parameters=c(gamma=0.1,beta=0.75)
time=seq(from=1,to=3*365,by=1)
#SIR Model function
sir_model3 <- function(time,state,parameters){
with(as.list(c(state,parameters)),{
N=S+I+R
lambda=beta*(I/N)
dS=-lambda*S
dI=lambda*S-gamma*I
dR=gamma*I
return(list(c(dS,dI,dR)))
}
)
}
# Solving the differential equations:
output<-as.data.frame(ode(y=initial_state_values,func = sir_model3,parms=parameters,times = time))
out_long=melt(output,id="time")
#Plot of prevalance
ggplot(data = out_long,
aes(x = time, y = value/1000000, colour = variable, group = variable)) +
geom_line() +
xlab("Time (days)")+
ylab("Prevalance") +scale_color_discrete(name="State")
initial_state_values=c(S=0.60*999999,I=1,R=0.75*999999)
parameters=c(gamma=0.1,beta=0.4)
time=seq(from=1,to=3*365,by=1)
#SIR Model function
sir_model3 <- function(time,state,parameters){
with(as.list(c(state,parameters)),{
N=S+I+R
lambda=beta*(I/N)
dS=-lambda*S
dI=lambda*S-gamma*I
dR=gamma*I
return(list(c(dS,dI,dR)))
}
)
}
# Solving the differential equations:
output<-as.data.frame(ode(y=initial_state_values,func = sir_model3,parms=parameters,times = time))
out_long=melt(output,id="time")
#Plot of prevalance
ggplot(data = out_long,
aes(x = time, y = value/1000000, colour = variable, group = variable)) +
geom_line() +
xlab("Time (days)")+
ylab("Prevalance") +scale_color_discrete(name="State")
#Loading libraries
library(ggplot2)
library(deSolve)
library(reshape2)
# Model inputs
initial_state_values=c(S=0.60*999999,I=1,R=0.40*999999)
parameters=c(gamma=0.1,beta=0.4)
# Time points
time=seq(from=1,to=3*365,by=1)
#SIR Model function
sir_model3 <- function(time,state,parameters){
with(as.list(c(state,parameters)),{
N=S+I+R
lambda=beta*(I/N)
dS=-lambda*S
dI=lambda*S-gamma*I
dR=gamma*I
return(list(c(dS,dI,dR)))
}
)
}
# Solving the differential equations:
output<-as.data.frame(ode(y=initial_state_values,func = sir_model3,parms=parameters,times = time))
out_long=melt(output,id="time")
#Plot of prevalance
ggplot(data = out_long,
aes(x = time, y = value/1000000, colour = variable, group = variable)) +
geom_line() +
xlab("Time (days)")+
ylab("Prevalance") +scale_color_discrete(name="State")
parameters=c(gamma=0.1,beta=0.7)
time=seq(from=1,to=3*365,by=1)
#SIR Model function
sir_model3 <- function(time,state,parameters){
with(as.list(c(state,parameters)),{
N=S+I+R
lambda=beta*(I/N)
dS=-lambda*S
dI=lambda*S-gamma*I
dR=gamma*I
return(list(c(dS,dI,dR)))
}
)
}
# Solving the differential equations:
output<-as.data.frame(ode(y=initial_state_values,func = sir_model3,parms=parameters,times = time))
out_long=melt(output,id="time")
#Plot of prevalance
ggplot(data = out_long,
aes(x = time, y = value/1000000, colour = variable, group = variable)) +
geom_line() +
xlab("Time (days)")+
ylab("Prevalance") +scale_color_discrete(name="State")
# Vaccine coverage
p <- 0.75
# Vector storing the initial number of people in each compartment (at timestep 0)
initial_state_values <- c(S = (1-p)*(N-1),   # a proportion 1-p of the total population is susceptible
I = 1,             # the epidemic starts with a single infected person
R = p*(N-1))       # a proportion p of the total population is vaccinated/immune
# Solving the differential equations using the ode integration algorithm
output <- as.data.frame(ode(y = initial_state_values,
times = times,
func = sir_model,
parms = parameters))
# LOAD THE PACKAGES:
library(deSolve)
library(reshape2)
library(ggplot2)
# MODEL INPUTS:
# Vaccine coverage
p <- 0.5
# Total population size
N <- 10^6
# Vector storing the initial number of people in each compartment (at timestep 0)
initial_state_values <- c(S = (1-p)*(N-1),   # a proportion 1-p of the total population is susceptible
I = 1,             # the epidemic starts with a single infected person
R = p*(N-1))       # a proportion p of the total population is vaccinated/immune
# Vector storing the parameters describing the transition rates in units of days^-1
parameters <- c(beta = 0.4,      # the infection rate, which acts on susceptibles
gamma = 0.1)     # the rate of recovery, which acts on those infected
# TIMESTEPS:
# Vector storing the sequence of timesteps to solve the model at
times <- seq(from = 0, to = 730, by = 1)   # from 0 to 730 days in daily intervals
# SIR MODEL FUNCTION:
# The model function takes as input arguments (in the following order): time, state and parameters
sir_model <- function(time, state, parameters) {
with(as.list(c(state, parameters)), {  # tell R to look for variable names within the state and parameters objects
# Calculating the total population size N (the sum of the number of people in each compartment)
N <- S+I+R
# Defining lambda as a function of beta and I:
lambda <- beta * I/N
# The differential equations
dS <- -lambda * S               # people move out of (-) the S compartment at a rate lambda (force of infection)
dI <- lambda * S - gamma * I    # people move into (+) the I compartment from S at a rate lambda,
# and move out of (-) the I compartment at a rate gamma (recovery)
dR <- gamma * I                 # people move into (+) the R compartment from I at a rate gamma
# Return the number of people in the S, I and R compartments at each timestep
# (in the same order as the input state variables)
return(list(c(dS, dI, dR)))
})
}
# MODEL OUTPUT (solving the differential equations):
# Solving the differential equations using the ode integration algorithm
output <- as.data.frame(ode(y = initial_state_values,
times = times,
func = sir_model,
parms = parameters))
output_long <- melt(as.data.frame(output), id = "time")                  # turn output dataset into long format
# Adding a column for the prevalence proportion to the long-format output
output_long$prevalence <- output_long$value/sum(initial_state_values)
# Plot the prevalence proportion
ggplot(data = output_long,                                               # specify object containing data to plot
aes(x = time, y = prevalence, colour = variable, group = variable)) +  # assign columns to axes and groups
geom_line() +                                                          # represent data as lines
xlab("Time (days)")+                                                   # add label for x axis
ylab("Prevalence (proportion)") +                                      # add label for y axis
labs(colour = "Compartment",                                           # add legend title
title = "Prevalence of infection, susceptibility and recovery over time")   # add plot title
# Vaccine coverage
p <- 0.75
# Vector storing the initial number of people in each compartment (at timestep 0)
initial_state_values <- c(S = (1-p)*(N-1),   # a proportion 1-p of the total population is susceptible
I = 1,             # the epidemic starts with a single infected person
R = p*(N-1))       # a proportion p of the total population is vaccinated/immune
# Solving the differential equations using the ode integration algorithm
output <- as.data.frame(ode(y = initial_state_values,
times = times,
func = sir_model,
parms = parameters))
output_long <- melt(as.data.frame(output), id = "time")                  # turn output dataset into long format
# Adding a column for the prevalence proportion to the long-format output
output_long$prevalence <- output_long$value/sum(initial_state_values)
# Plot the prevalence proportion
ggplot(data = output_long,                                               # specify object containing data to plot
aes(x = time, y = prevalence, colour = variable, group = variable)) +  # assign columns to axes and groups
geom_line() +                                                          # represent data as lines
xlab("Time (days)")+                                                   # add label for x axis
ylab("Prevalence (proportion)") +                                      # add label for y axis
labs(colour = "Compartment",                                           # add legend title
title = "Prevalence of infection, susceptibility and recovery over time")   # add plot title
# Vaccine coverage
p <- 0.50
# Vector storing the initial number of people in each compartment (at timestep 0)
initial_state_values <- c(S = (1-p)*(N-1),   # a proportion 1-p of the total population is susceptible
I = 1,             # the epidemic starts with a single infected person
R = p*(N-1))       # a proportion p of the total population is vaccinated/immune
# Solving the differential equations using the ode integration algorithm
output <- as.data.frame(ode(y = initial_state_values,
times = times,
func = sir_model,
parms = parameters))
output_long <- melt(as.data.frame(output), id = "time")                  # turn output dataset into long format
# Adding a column for the prevalence proportion to the long-format output
output_long$prevalence <- output_long$value/sum(initial_state_values)
# Plot the prevalence proportion
ggplot(data = output_long,                                               # specify object containing data to plot
aes(x = time, y = prevalence, colour = variable, group = variable)) +  # assign columns to axes and groups
geom_line() +                                                          # represent data as lines
xlab("Time (days)")+                                                   # add label for x axis
ylab("Prevalence (proportion)") +                                      # add label for y axis
labs(colour = "Compartment",                                           # add legend title
title = "Prevalence of infection, susceptibility and recovery over time")   # add plot title
# Vaccine coverage
p <- 0.72
# Vector storing the initial number of people in each compartment (at timestep 0)
initial_state_values <- c(S = (1-p)*(N-1),   # a proportion 1-p of the total population is susceptible
I = 1,             # the epidemic starts with a single infected person
R = p*(N-1))       # a proportion p of the total population is vaccinated/immune
# Solving the differential equations using the ode integration algorithm
output <- as.data.frame(ode(y = initial_state_values,
times = times,
func = sir_model,
parms = parameters))
output_long <- melt(as.data.frame(output), id = "time")                  # turn output dataset into long format
# Adding a column for the prevalence proportion to the long-format output
output_long$prevalence <- output_long$value/sum(initial_state_values)
# Plot the prevalence proportion
ggplot(data = output_long,                                               # specify object containing data to plot
aes(x = time, y = prevalence, colour = variable, group = variable)) +  # assign columns to axes and groups
geom_line() +                                                          # represent data as lines
xlab("Time (days)")+                                                   # add label for x axis
ylab("Prevalence (proportion)") +                                      # add label for y axis
labs(colour = "Compartment",                                           # add legend title
title = "Prevalence of infection, susceptibility and recovery over time")   # add plot title
>>>>>>> 6182cbec7f93fd3d35fb8a0cd0c7bed112d27662
use_readme_rmd(open = rlang::is_interactive())
library(usethis)
use_readme_rmd(open = rlang::is_interactive())
usethis::use_github_action_check_standard()
usethis::use_github_action_check_standard()
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager") #
library(LEA)
install
knitr::opts_chunk$set(echo = TRUE)
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
?gfData
??gfData
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
library(LEA)
?gfData
#make sure you have installed devtools previously.
#Install the most uptodate version from github
#if (!requireNamespace("devtools", quietly = TRUE))
# install.packages("devtools")
#devtools:: install_github('nfj1380/mrIML')
library(mrIML)
#other package we need:
library(vip); library(tidymodels); library(randomForest);  library(caret); library(gbm);
library(tidyverse);library(parallel); library(doParallel); library(themis); library(viridis); library(janitor); library(hrbrthemes); library(xgboost); library(vegan);library(flashlight);
library(ggrepel)
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("LEA")
#make sure you have installed devtools previously.
#Install the most uptodate version from github
#if (!requireNamespace("devtools", quietly = TRUE))
# install.packages("devtools")
#devtools:: install_github('nfj1380/mrIML')
library(mrIML)
#other package we need:
library(vip); library(tidymodels); library(randomForest);  library(caret); library(gbm);
library(tidyverse);library(parallel); library(doParallel); library(themis); library(viridis); library(janitor); library(hrbrthemes); library(xgboost); library(vegan);library(flashlight);
library(ggrepel)
#library(LEA)
# read in data file with minor allele freqs & env/space variables
gfData; str(gfData)
envGF <- gfData[,3:13] # get climate & MEM variables
Y <- envGF #for simplicity
# build individual SNP datasets
SNPs_ref <- gfData[,grep("REFERENCE",colnames(gfData))] # reference
GI5 <- gfData[,grep("GI5",colnames(gfData))] # GIGANTEA-5 (GI5)
X <- GI5 #for this example we are going to focus on the adaptive SNPs in the GI5 region.
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
gfData; str(gfData)
str()
str
?str\
?str
pkgdown::build_site()
build_home()
build_news()
pkgdown::build_site()
pkgdown::build_site()
