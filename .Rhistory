pd_ <- light_profile(fl, v = paste0(var_names[j]))
#add number of boostrap.
bs_rep <- data.frame( bootstrap=rep(i, nrow(pd_$data)))
#response name
bs_name <- data.frame( response=rep(names(Y[k]), nrow(pd_$data)))
pd_data <-data.frame(cbind(pd_$data),  bs_name, bs_rep) #add bootstrap
pd_raw[[i]][[var_names[j]]] <- pd_data  # Save pd_ as a list element
}
}
gc() #clear junk
return(pd_raw)  # Return pd_raw as a list
}
bstraps_pd_list <- future_lapply(seq(1, n_response), internal_fit_function, future.seed = TRUE)
return(bstraps_pd_list)
}
bs_malaria <- mrBootstrap(yhats=yhats_rf,Y=Y, num_bootstrap = 10)
?data_table
#' Bootstrap model predictions
#'
#' This function bootstraps model predictions and generates variable profiles
#' for each response variable based on the provided yhats.
#'
#' @param yhats A list of model predictions mrIMLpredicts
#' @param num_bootstrap The number of bootstrap samples to generate (default: 10).
#' @param Y The response data (default: Y).
#' @return A list containing bootstrap samples of variable profiles for each response variable.
#' @export
#'
#' @examples
#' \dontrun{
#' # Example usage:
#' #set up analysis
#' Y <- dplyr::select(Bird.parasites, -scale.prop.zos)%>%
#' dplyr::select(sort(names(.)))#response variables eg. SNPs, pathogens, species....
#' X <- dplyr::select(Bird.parasites, scale.prop.zos) # feature set
#' X1 <- Y %>%
#' dplyr::select(sort(names(.)))
#'model_rf <-
#' rand_forest(trees = 100, mode = "classification", mtry = tune(), min_n = tune()) %>% #100 trees are set for brevity. Aim to start with 1000
#' set_engine("randomForest")
#' yhats_rf <- mrIMLpredicts(X=X, Y=Y,
#'X1=X1,'Model=model_rf ,
#'balance_data='no',mode='classification',
#'tune_grid_size=5,seed = sample.int(1e8, 1),'morans=F,
#'prop=0.7, k=5, racing=T) #
#'
#'bs_analysis <- mrBootstrap(yhats=yhats_rf,Y=Y, num_bootstrap = 5)
#'}
mrBootstrap <- function(yhats, num_bootstrap = 10, Y=Y) {
n_response <- length(yhats)
pb <- txtProgressBar(min = 0, max = n_response, style = 3)
# pb <- progress::progress_bar$new(format = "[:bar] :percent ETA: :eta", total = n_response )
#metric list for flashlight. Currently only for classification
metrics <- list(
logloss = MetricsWeighted::logLoss,
`ROC AUC` = MetricsWeighted::AUC,
`% Dev Red` = MetricsWeighted::r_squared_bernoulli
)
internal_fit_function <- function(k) {
setTxtProgressBar(pb, k) #progressbar marker
# pb$tick()
features <- colnames(yhats[[k]]$data)[-1]
n <- nrow(yhats[[k]]$data)
pd_raw <- vector("list", num_bootstrap)  # Initialize pd_raw as a list
for (i in 1:num_bootstrap) {
# Generate bootstrap sample
#bootstrap_sample <- yhats[[k]]$data[sample(1:n, replace = TRUE), ] ###
# Convert the data frame to a data table
data_table <- data.table::as.data.table(yhats[[k]]$data)
# Generate random row indices
sample_indices <- sample(1:n, n, replace = TRUE)
# Create the bootstrap sample using data table syntax
bootstrap_sample <- data_table[sample_indices]
# Extract the workflow from the best fit
wflow <- yhats[[k]]$last_mod_fit %>% tune::extract_workflow()
# Add the bootstrap data to the workflow
wflow$data <- bootstrap_sample
# Fit the model using the bootstrap sample
model_fit <- fit(wflow, data = bootstrap_sample)
# Create explainer
var_names <- names(yhats[[k]]$data)[-1]
pred_fun <- function(m, dat) {
predict(
m, dat[, colnames(bootstrap_sample)[-1], drop = FALSE],
type = "prob"
)$`.pred_1`
}
fl <- flashlight(
model = model_fit,
label = 'class',
data = bootstrap_sample,
y = 'class',
predict_function = pred_fun,
metrics = metrics
)
for (j in seq_along(var_names)) {
pd_ <- light_profile(fl, v = paste0(var_names[j]))
#add number of boostrap.
bs_rep <- data.frame( bootstrap=rep(i, nrow(pd_$data)))
#response name
bs_name <- data.frame( response=rep(names(Y[k]), nrow(pd_$data)))
pd_data <-data.frame(cbind(pd_$data),  bs_name, bs_rep) #add bootstrap
pd_raw[[i]][[var_names[j]]] <- pd_data  # Save pd_ as a list element
}
}
gc() #clear junk
return(pd_raw)  # Return pd_raw as a list
}
bstraps_pd_list <- future_lapply(seq(1, n_response), internal_fit_function, future.seed = TRUE)
return(bstraps_pd_list)
}
bs_malaria <- mrBootstrap(yhats=yhats_rf,Y=Y, num_bootstrap = 10)
gc()
gc()
#' Bootstrap model predictions
#'
#' This function bootstraps model predictions and generates variable profiles
#' for each response variable based on the provided yhats.
#'
#' @param yhats A list of model predictions mrIMLpredicts
#' @param num_bootstrap The number of bootstrap samples to generate (default: 10).
#' @param Y The response data (default: Y).
#' @return A list containing bootstrap samples of variable profiles for each response variable.
#' @export
#'
#' @examples
#' \dontrun{
#' # Example usage:
#' #set up analysis
#' Y <- dplyr::select(Bird.parasites, -scale.prop.zos)%>%
#' dplyr::select(sort(names(.)))#response variables eg. SNPs, pathogens, species....
#' X <- dplyr::select(Bird.parasites, scale.prop.zos) # feature set
#' X1 <- Y %>%
#' dplyr::select(sort(names(.)))
#'model_rf <-
#' rand_forest(trees = 100, mode = "classification", mtry = tune(), min_n = tune()) %>% #100 trees are set for brevity. Aim to start with 1000
#' set_engine("randomForest")
#' yhats_rf <- mrIMLpredicts(X=X, Y=Y,
#'X1=X1,'Model=model_rf ,
#'balance_data='no',mode='classification',
#'tune_grid_size=5,seed = sample.int(1e8, 1),'morans=F,
#'prop=0.7, k=5, racing=T) #
#'
#'bs_analysis <- mrBootstrap(yhats=yhats_rf,Y=Y, num_bootstrap = 5)
#'}
mrBootstrap <- function(yhats, num_bootstrap = 10, Y=Y) {
n_response <- length(yhats)
pb <- txtProgressBar(min = 0, max = n_response, style = 3)
# pb <- progress::progress_bar$new(format = "[:bar] :percent ETA: :eta", total = n_response )
#metric list for flashlight. Currently only for classification
metrics <- list(
logloss = MetricsWeighted::logLoss,
`ROC AUC` = MetricsWeighted::AUC,
`% Dev Red` = MetricsWeighted::r_squared_bernoulli
)
internal_fit_function <- function(k) {
setTxtProgressBar(pb, k) #progressbar marker
# pb$tick()
features <- colnames(yhats[[k]]$data)[-1]
n <- nrow(yhats[[k]]$data)
pd_raw <- vector("list", num_bootstrap)  # Initialize pd_raw as a list
for (i in 1:num_bootstrap) {
# Generate bootstrap sample
#bootstrap_sample <- yhats[[k]]$data[sample(1:n, replace = TRUE), ] ###
# Convert the data frame to a data table
data_table <- data.table::as.data.table(yhats[[k]]$data)
# Generate random row indices
sample_indices <- sample(1:n, replace = TRUE)
# Create the bootstrap sample using data table syntax
bootstrap_sample <- data_table[sample_indices]
# Extract the workflow from the best fit
wflow <- yhats[[k]]$last_mod_fit %>% tune::extract_workflow()
# Add the bootstrap data to the workflow
wflow$data <- bootstrap_sample
# Fit the model using the bootstrap sample
model_fit <- fit(wflow, data = bootstrap_sample)
# Create explainer
var_names <- names(yhats[[k]]$data)[-1]
pred_fun <- function(m, dat) {
predict(
m, dat[, colnames(bootstrap_sample)[-1], drop = FALSE],
type = "prob"
)$`.pred_1`
}
fl <- flashlight(
model = model_fit,
label = 'class',
data = bootstrap_sample,
y = 'class',
predict_function = pred_fun,
metrics = metrics
)
for (j in seq_along(var_names)) {
pd_ <- light_profile(fl, v = paste0(var_names[j]))
#add number of boostrap.
bs_rep <- data.frame( bootstrap=rep(i, nrow(pd_$data)))
#response name
bs_name <- data.frame( response=rep(names(Y[k]), nrow(pd_$data)))
pd_data <-data.frame(cbind(pd_$data),  bs_name, bs_rep) #add bootstrap
pd_raw[[i]][[var_names[j]]] <- pd_data  # Save pd_ as a list element
}
}
gc() #clear junk
return(pd_raw)  # Return pd_raw as a list
}
bstraps_pd_list <- future_lapply(seq(1, n_response), internal_fit_function, future.seed = TRUE)
return(bstraps_pd_list)
}
bs_malaria <- mrBootstrap(yhats=yhats_rf,Y=Y, num_bootstrap = 10)
bs_impVIa <- mrVI_bootstrap(mrBootstrap_obj=bs_malaria, ModelPerf=ModelPerf,
threshold=0.5,  X=X, Y=Y, global_top_var=10,
local_top_var=10)
bs_impVIa[[2]]
otu_table_ostrich <- read_tsv('gut_otu_table.tsv')
setwd("~/MrIML")
otu_table_ostrich <- read_tsv('gut_otu_table.tsv')
otu_table_ostrich <- read_tsv('gut_otu_table.tsv')
taxa_table_ostrich <- read_tsv('gut_tax_table.tsv')
#check identical
identical_column <- identical(taxa_table_ostrich$ASV, otu_table_ostrich$ASV)
# Output the result
if (identical_column) {
print("The 'ColumnName' matches identically.")
} else {
print("The 'ColumnName' does not match identically.")
}
#ASV column not needed
taxa_table_ostrich$ASV <- NULL
taxa_table_ostrich$Kingdom<- NULL
taxa_table_ostrich$Class<- NULL
taxa_table_ostrich$Phylum<- NULL
#create_names
create_name <- function(row) {
non_na_values <- na.omit(row)
unique_values <- unique(non_na_values)  # Remove duplicates
if (length(unique_values) > 3) {
unique_values <- unique_values[1:2]
}
# Extract genus and species names if available
family <- ifelse("Family" %in% names(row), row["Family"], NA)
genus <- ifelse("Genus" %in% names(row), row["Genus"], NA)
species <- ifelse("Species" %in% names(row), row["Species"], NA)
# Combine genus, species, and unique values into a name
name_parts <- c(family,genus, species, unique_values)
name_parts <- name_parts[!is.na(name_parts)]  # Remove NA values
return(paste(name_parts, collapse = "_"))
}
# Create the 'Name' column
taxa_table_ostrich$Name <- apply(taxa_table_ostrich, 1, create_name)
#make names unique
make_names_unique <- function(names_vector, remove_duplicates = character(0)) {
# Remove specified strings (e.g., "Clostridiales") from the names vector
names_vector <- names_vector[!names_vector %in% remove_duplicates]
# Create a named vector to keep track of counts for each name
name_counts <- numeric(length(names_vector))
names(name_counts) <- names_vector
# Initialize a result vector
result_names <- character(length(names_vector))
for (i in seq_along(names_vector)) {
name <- names_vector[i]
# Check if the name exists in name_counts
if (!is.na(name_counts[name])) {
# Check if the name has occurred before
if (name_counts[name] > 1) {
# Append a number to make the name unique
result_names[i] <- paste0(name, "_", name_counts[name])
} else {
result_names[i] <- name
}
# Update the count for this name
name_counts[name] <- name_counts[name] + 1
} else {
# If name doesn't exist in name_counts, treat it as the first occurrence
result_names[i] <- name
name_counts[name] <- 1
}
}
return(result_names)
}
taxa_table_ostrich$Name_f <- make_names_unique(taxa_table_ostrich$Name)
replace_empty_names <- function(names_vector) {
# Find indices where names are empty
empty_indices <- names_vector == ""
# Count occurrences of empty names
empty_counts <- cumsum(empty_indices)
# Replace empty names with "Taxon" followed by count
names_vector[empty_indices] <- paste0("Taxon ", empty_counts[empty_indices])
return(names_vector)
}
taxa_table_ostrich$Name_comp <-replace_empty_names(taxa_table_ostrich$Name_f)
make_names_unique3 <- function(names_vector) {
# Initialize a counter to keep track of occurrences of each name
name_counts <- list()
# Initialize a result vector to store the modified names
result_names <- character(length(names_vector))
for (i in seq_along(names_vector)) {
name <- names_vector[i]
# Check if the name is empty or has occurred before
if (name == "" || is.null(name_counts[[name]]) || name_counts[[name]] > 0) {
# Increment the count for this name
count <- ifelse(is.null(name_counts[[name]]), 1, name_counts[[name]] + 1)
name_counts[[name]] <- count
# Append a number to make the name unique
result_names[i] <- paste0(name, ".", count)
} else {
result_names[i] <- name
# First occurrence of this name, initialize count to 1
name_counts[[name]] <- 1
}
}
return(result_names)
}
taxa_table_ostrich$Name_comp1 <- make_names_unique3(taxa_table_ostrich$Name_comp)
#make sure names match
final_ASV_table <- otu_table_ostrich
final_ASV_table$ASV <- taxa_table_ostrich$Name_comp1
#add row names
final_ASV_table_r <- final_ASV_table %>%
column_to_rownames(var='ASV')
#get into right format for MrIML
final_ASV_table_df <-as.data.frame(t(final_ASV_table_r ))
#make presence/absence
pa_ASV_table <- final_ASV_table_df %>%
mutate_all(~ ifelse(. > 0, 1, .))
#remove rare and common ASVs
Y <- filterRareCommon(pa_ASV_table , lower=0.2, higher=0.8) %>%
dplyr::select(sort(names(.))) #0.1 for final analysis. 0.2=276 0.1=695
glimpse(Y)
View(Y)
X1 <- Y
DataExplorer::introduce(Y)
metadata_ostrich <- read_tsv('gut_metadata.tsv')
glimpse(metadata_ostrich)
DataExplorer::introduce(metadata_ostrich)
DataExplorer::create_report(metadata_ostrich)
#remove a few
metadata_ostrich$AgeDied <- NULL #same as age
metadata_ostrich$Method <- NULL #all the same
metadata_ostrich$AgeWeek <- NULL #not needed?
metadata_ostrich$WeightPM <- NULL #highly correlated with weight
#match with ASVs
identical_column <- identical(row.names(Y), metadata_ostrich$X.SampleID)
# Output the result
if (identical_column) {
print("The 'ColumnName' matches identically.")
} else {
print("The 'ColumnName' does not match identically.")
}
Xmissing <- metadata_ostrich %>% column_to_rownames(var='X.SampleID')
X_fact <- Xmissing %>%  select(where(is.character)) %>%
mutate(across(where(is.character), factor))
str(X_fact )
#permute missing values
Xmissing_num <- Xmissing %>% select(where(is.numeric))
X_ <- missForest::missForest(Xmissing_num)
X <- cbind(X_$ximp, X_fact)
DataExplorer::introduce(X)
View(X)
X$ID <- NULL #not needed
model_rf <-
rand_forest(trees = 100, mode = "classification", mtry = tune(), min_n = tune()) %>% #100 trees are set for brevity. Aim to start with 1000
set_engine("randomForest")
cl <- parallel::makeCluster(5)
plan(cluster, workers=cl)
yhats_rf <- mrIMLpredicts(X=X, Y=Y,
X1=X1,
Model=model_rf , #lm/xgb not working on avian malaria
balance_data='down',
mode='classification',
tune_grid_size=5,
seed = sample.int(1e8, 1),
morans=F,
prop=0.7, k=5, racing=T)
saveRDS(yhats_rf, 'ostrich_microbiome_rf_model')
ModelPerf <- mrIMLperformance(yhats_rf, Model=model_rf, Y=Y, mode='classification')
m <- ModelPerf[[1]]
m
VI <- mrVip(yhats=yhats_rf, X, Y)
#--------------------------------------------------
#these functions dont work on JSDM data
#Variable importance
VI <- mrVip(yhats=yhats_rf, X)
vi_i <- interpret_Mrvi(VI=VI, modelPerf=ModelPerf,Y, X=cbind(X,Y),
groupCov = NULL, cutoff = 0.5, mode = "classification" )
gc()
bs_ostrich <- mrBootstrap(yhats=yhats_rf, Y=Y, num_bootstrap = 2)
gc()
setwd("~/MrIML/mriml2_chaw")
knitr::opts_chunk$set(echo = TRUE)
pacman::p_load('MRFcov', 'mrIML', 'tidyverse', 'future.apply','tidymodels', 'finetune', 'themis', 'vip', 'flashlight', 'iml', 'vivid', 'igraph', 'ggnetwork', 'network',
'gridExtra', 'xgboost', 'brulee', 'fastshap', 'tabnet', 'bonsai',
'parsnip', 'cowplot', 'progress', 'hstats', 'geosphere')
setwd("/Users/chawhsuthwe/Desktop/PHD/MrIML/mrimlv2")
library(mrIML)
Y <- readRDS("Y_nokinship.rds")
X <- readRDS("X_nokinship18pcs.rds")
X <- X[, 1:18] #PC10
X <- X[, -6] #remove skin color
X <- X[,-1] #remove sex because bootstrap doesn't work with it
X1 <- Y %>%
dplyr::select(sort(names(.)))
X1_fact <- X1 %>%
mutate_all(as.factor) %>%
mutate_all(~ifelse(. == 0, "absent", "present"))
model_rf <-
rand_forest(trees = 100, mode = "classification", mtry = tune(), min_n = tune()) %>% #100 trees are set for brevity. Aim to start with 1000
set_engine("randomForest")
model_lm <- #model used to generate yhat
logistic_reg() %>%
set_engine("glm") %>%
set_mode("classification") #just for your response
cl <- parallel::makeCluster(28)
plan(cluster, workers=cl)
cl <- parallel::makeCluster(5)
plan(cluster, workers=cl)
View(X)
#random forest
yhats_rf <- mrIMLpredicts(X=X, Y=Y,
X1=X1,
spatial_data= NULL, #no spatial data here
Model=model_rf,
balance_data='no',
mode='classification',
seed = sample.int(1e8, 1),
morans=F,
prop=0.7, k=5, racing=T)
#linear model
yhats_lm <- mrIMLpredicts(X=X,Y=Y,
X1=X1_fact,
Model=model_lm ,
balance_data='no',
mode='classification',
seed = sample.int(1e8, 1),
prop=0.6, racing=F, k=5)
#random forest
yhats_rf <- mrIMLpredicts(X=X, Y=Y,
X1=X1,
Model=model_rf,
balance_data='no',
mode='classification',
seed = sample.int(1e8, 1),
morans=F,
prop=0.7, k=5, racing=T)
#linear model
yhats_lm <- mrIMLpredicts(X=X,Y=Y,
X1=X1_fact,
Model=model_lm ,
balance_data='no',
mode='classification',
seed = sample.int(1e8, 1),
prop=0.6, racing=F, k=5)
cl <- parallel::makeCluster(5)
plan(cluster, workers=cl)
Y <- readRDS("Y_nokinship.rds") %>%
dplyr::select(sort(names(.)))
X <- readRDS("X_nokinship18pcs.rds")
X <- X[, 1:18] #PC10
X <- X[, -6] #remove skin color
X <- X[,-1] #remove sex because bootstrap doesn't work with it
Y <- readRDS("Y_nokinship.rds") %>%
dplyr::select(sort(names(.)))
X <- readRDS("X_nokinship18pcs.rds")
X <- X[, 1:18] #PC10
X <- X[, -6] #remove skin color
X <- X[,-1] #remove sex because bootstrap doesn't work with it
X1 <- Y
X1_fact <- X1 %>%
mutate_all(as.factor) %>%
mutate_all(~ifelse(. == 0, "absent", "present"))
X1_fact,
#random forest
yhats_rf <- mrIMLpredicts(X=X, Y=Y,
X1=X1_fact,
Model=model_rf,
balance_data='no',
mode='classification',
seed = sample.int(1e8, 1),
morans=F,
prop=0.7, k=5, racing=T)
#linear model
yhats_lm <- mrIMLpredicts(X=X,Y=Y,
X1=X1_fact,
Model=model_lm ,
balance_data='no',
mode='classification',
seed = sample.int(1e8, 1),
prop=0.6, racing=F, k=5)
#random forest
yhats_rf <- mrIMLpredicts(X=X, Y=Y,
#X1=X1_fact,
Model=model_rf,
balance_data='no',
mode='classification',
seed = sample.int(1e8, 1),
morans=F,
prop=0.7, k=5, racing=T)
#linear model
yhats_lm <- mrIMLpredicts(X=X,Y=Y,
X1=X1_fact,
Model=model_lm ,
balance_data='no',
mode='classification',
seed = sample.int(1e8, 1),
prop=0.6, racing=F, k=5)
ModelPerf_rf <- mrIMLperformance(yhats_lm, Model=model_lm, Y=Y, mode='classification')
ModelPerf_rf[[1]]
ModelPerf_rf[[2]]
ModelPerf_rf <- mrIMLperformance(yhats_rf, Model=model_lm, Y=Y, mode='classification')
ModelPerf_rf[[1]]
ModelPerf_rf[[2]]
range(X$birthplace.N)
View(X)
