with(as.list(c(state,parameters)),{
N=S+I+R
lambda=beta*(I/N)
dS=-lambda*S
dI=lambda*S-gamma*I
dR=gamma*I
return(list(c(dS,dI,dR)))
}
)
}
#Solving the differential equations
output<-as.data.frame(ode(y=initial_state_values,func = sir_model,parms=parameters,times = time))
#Load required libraries
library(ggplot2)
library(deSolve)
install.packages("deSolve")
#Load required libraries
library(ggplot2)
library(deSolve)
library(reshape2)
# Model inputs
initial_state_values=c(S=999999,I=1,R=0)
parameters=c(gamma=0.20,beta=0.5)
# Time points
time=seq(from=1,to=100,by=1)
# SIR model function
sir_model <- function(time,state,parameters){
with(as.list(c(state,parameters)),{
N=S+I+R
lambda=beta*(I/N)
dS=-lambda*S
dI=lambda*S-gamma*I
dR=gamma*I
return(list(c(dS,dI,dR)))
}
)
}
#Solving the differential equations
output<-as.data.frame(ode(y=initial_state_values,func = sir_model,parms=parameters,times = time))
out_long=melt(output,id="time")
# To plot the proportion of susceptible, infected and recovered individuals over time
ggplot(data = out_long,
aes(x = time, y = value/1000000, colour = variable, group = variable)) +
geom_line() +xlab("Time (days)")+ylab("Proportion of the population")+
scale_color_discrete(name="State")
library(ggplot2)
library(deSolve)
library(reshape2)
# Model inputs
initial_state_values=c(S=999999,I=1,R=0)
parameters=c(gamma=0.2*365,beta=0.4*365,mu=1/70,b=1/70)
# Time points
time=seq(from=1,to=400,by=1/365)
# SIR model function
sir_model2 <- function(time,state,parameters){
with(as.list(c(state,parameters)),{
N=S+I+R
lambda=beta*(I/N)
dS=-lambda*S-mu*S+b*N
dI=lambda*S-gamma*I-mu*I
dR=gamma*I-mu*R
return(list(c(dS,dI,dR)))
}
)
}
# Solving the differential equations:
output<-as.data.frame(ode(y=initial_state_values,func = sir_model2,parms=parameters,times = time))
out_long=melt(output,id="time")
#Plotting the prevelance over time
ggplot(data = out_long,
aes(x = time, y = value/1000000, colour = variable, group = variable)) +
geom_line() +
xlab("Time (years)")+
ylab("Prevalence") + scale_color_discrete(name="State")
#Loading libraries
library(ggplot2)
library(deSolve)
library(reshape2)
# Model inputs
initial_state_values=c(S=0.60*999999,I=1,R=0.40*999999)
parameters=c(gamma=0.1,beta=0.4)
# Time points
time=seq(from=1,to=3*365,by=1)
#SIR Model function
sir_model3 <- function(time,state,parameters){
with(as.list(c(state,parameters)),{
N=S+I+R
lambda=beta*(I/N)
dS=-lambda*S
dI=lambda*S-gamma*I
dR=gamma*I
return(list(c(dS,dI,dR)))
}
)
}
# Solving the differential equations:
output<-as.data.frame(ode(y=initial_state_values,func = sir_model3,parms=parameters,times = time))
out_long=melt(output,id="time")
#Plot of prevalance
ggplot(data = out_long,
aes(x = time, y = value/1000000, colour = variable, group = variable)) +
geom_line() +
xlab("Time (days)")+
ylab("Prevalance") +scale_color_discrete(name="State")
parameters=c(gamma=0.1,beta=0.75)
time=seq(from=1,to=3*365,by=1)
#SIR Model function
sir_model3 <- function(time,state,parameters){
with(as.list(c(state,parameters)),{
N=S+I+R
lambda=beta*(I/N)
dS=-lambda*S
dI=lambda*S-gamma*I
dR=gamma*I
return(list(c(dS,dI,dR)))
}
)
}
# Solving the differential equations:
output<-as.data.frame(ode(y=initial_state_values,func = sir_model3,parms=parameters,times = time))
out_long=melt(output,id="time")
#Plot of prevalance
ggplot(data = out_long,
aes(x = time, y = value/1000000, colour = variable, group = variable)) +
geom_line() +
xlab("Time (days)")+
ylab("Prevalance") +scale_color_discrete(name="State")
initial_state_values=c(S=0.60*999999,I=1,R=0.75*999999)
parameters=c(gamma=0.1,beta=0.4)
time=seq(from=1,to=3*365,by=1)
#SIR Model function
sir_model3 <- function(time,state,parameters){
with(as.list(c(state,parameters)),{
N=S+I+R
lambda=beta*(I/N)
dS=-lambda*S
dI=lambda*S-gamma*I
dR=gamma*I
return(list(c(dS,dI,dR)))
}
)
}
# Solving the differential equations:
output<-as.data.frame(ode(y=initial_state_values,func = sir_model3,parms=parameters,times = time))
out_long=melt(output,id="time")
#Plot of prevalance
ggplot(data = out_long,
aes(x = time, y = value/1000000, colour = variable, group = variable)) +
geom_line() +
xlab("Time (days)")+
ylab("Prevalance") +scale_color_discrete(name="State")
#Loading libraries
library(ggplot2)
library(deSolve)
library(reshape2)
# Model inputs
initial_state_values=c(S=0.60*999999,I=1,R=0.40*999999)
parameters=c(gamma=0.1,beta=0.4)
# Time points
time=seq(from=1,to=3*365,by=1)
#SIR Model function
sir_model3 <- function(time,state,parameters){
with(as.list(c(state,parameters)),{
N=S+I+R
lambda=beta*(I/N)
dS=-lambda*S
dI=lambda*S-gamma*I
dR=gamma*I
return(list(c(dS,dI,dR)))
}
)
}
# Solving the differential equations:
output<-as.data.frame(ode(y=initial_state_values,func = sir_model3,parms=parameters,times = time))
out_long=melt(output,id="time")
#Plot of prevalance
ggplot(data = out_long,
aes(x = time, y = value/1000000, colour = variable, group = variable)) +
geom_line() +
xlab("Time (days)")+
ylab("Prevalance") +scale_color_discrete(name="State")
parameters=c(gamma=0.1,beta=0.7)
time=seq(from=1,to=3*365,by=1)
#SIR Model function
sir_model3 <- function(time,state,parameters){
with(as.list(c(state,parameters)),{
N=S+I+R
lambda=beta*(I/N)
dS=-lambda*S
dI=lambda*S-gamma*I
dR=gamma*I
return(list(c(dS,dI,dR)))
}
)
}
# Solving the differential equations:
output<-as.data.frame(ode(y=initial_state_values,func = sir_model3,parms=parameters,times = time))
out_long=melt(output,id="time")
#Plot of prevalance
ggplot(data = out_long,
aes(x = time, y = value/1000000, colour = variable, group = variable)) +
geom_line() +
xlab("Time (days)")+
ylab("Prevalance") +scale_color_discrete(name="State")
# Vaccine coverage
p <- 0.75
# Vector storing the initial number of people in each compartment (at timestep 0)
initial_state_values <- c(S = (1-p)*(N-1),   # a proportion 1-p of the total population is susceptible
I = 1,             # the epidemic starts with a single infected person
R = p*(N-1))       # a proportion p of the total population is vaccinated/immune
# Solving the differential equations using the ode integration algorithm
output <- as.data.frame(ode(y = initial_state_values,
times = times,
func = sir_model,
parms = parameters))
# LOAD THE PACKAGES:
library(deSolve)
library(reshape2)
library(ggplot2)
# MODEL INPUTS:
# Vaccine coverage
p <- 0.5
# Total population size
N <- 10^6
# Vector storing the initial number of people in each compartment (at timestep 0)
initial_state_values <- c(S = (1-p)*(N-1),   # a proportion 1-p of the total population is susceptible
I = 1,             # the epidemic starts with a single infected person
R = p*(N-1))       # a proportion p of the total population is vaccinated/immune
# Vector storing the parameters describing the transition rates in units of days^-1
parameters <- c(beta = 0.4,      # the infection rate, which acts on susceptibles
gamma = 0.1)     # the rate of recovery, which acts on those infected
# TIMESTEPS:
# Vector storing the sequence of timesteps to solve the model at
times <- seq(from = 0, to = 730, by = 1)   # from 0 to 730 days in daily intervals
# SIR MODEL FUNCTION:
# The model function takes as input arguments (in the following order): time, state and parameters
sir_model <- function(time, state, parameters) {
with(as.list(c(state, parameters)), {  # tell R to look for variable names within the state and parameters objects
# Calculating the total population size N (the sum of the number of people in each compartment)
N <- S+I+R
# Defining lambda as a function of beta and I:
lambda <- beta * I/N
# The differential equations
dS <- -lambda * S               # people move out of (-) the S compartment at a rate lambda (force of infection)
dI <- lambda * S - gamma * I    # people move into (+) the I compartment from S at a rate lambda,
# and move out of (-) the I compartment at a rate gamma (recovery)
dR <- gamma * I                 # people move into (+) the R compartment from I at a rate gamma
# Return the number of people in the S, I and R compartments at each timestep
# (in the same order as the input state variables)
return(list(c(dS, dI, dR)))
})
}
# MODEL OUTPUT (solving the differential equations):
# Solving the differential equations using the ode integration algorithm
output <- as.data.frame(ode(y = initial_state_values,
times = times,
func = sir_model,
parms = parameters))
output_long <- melt(as.data.frame(output), id = "time")                  # turn output dataset into long format
# Adding a column for the prevalence proportion to the long-format output
output_long$prevalence <- output_long$value/sum(initial_state_values)
# Plot the prevalence proportion
ggplot(data = output_long,                                               # specify object containing data to plot
aes(x = time, y = prevalence, colour = variable, group = variable)) +  # assign columns to axes and groups
geom_line() +                                                          # represent data as lines
xlab("Time (days)")+                                                   # add label for x axis
ylab("Prevalence (proportion)") +                                      # add label for y axis
labs(colour = "Compartment",                                           # add legend title
title = "Prevalence of infection, susceptibility and recovery over time")   # add plot title
# Vaccine coverage
p <- 0.75
# Vector storing the initial number of people in each compartment (at timestep 0)
initial_state_values <- c(S = (1-p)*(N-1),   # a proportion 1-p of the total population is susceptible
I = 1,             # the epidemic starts with a single infected person
R = p*(N-1))       # a proportion p of the total population is vaccinated/immune
# Solving the differential equations using the ode integration algorithm
output <- as.data.frame(ode(y = initial_state_values,
times = times,
func = sir_model,
parms = parameters))
output_long <- melt(as.data.frame(output), id = "time")                  # turn output dataset into long format
# Adding a column for the prevalence proportion to the long-format output
output_long$prevalence <- output_long$value/sum(initial_state_values)
# Plot the prevalence proportion
ggplot(data = output_long,                                               # specify object containing data to plot
aes(x = time, y = prevalence, colour = variable, group = variable)) +  # assign columns to axes and groups
geom_line() +                                                          # represent data as lines
xlab("Time (days)")+                                                   # add label for x axis
ylab("Prevalence (proportion)") +                                      # add label for y axis
labs(colour = "Compartment",                                           # add legend title
title = "Prevalence of infection, susceptibility and recovery over time")   # add plot title
# Vaccine coverage
p <- 0.50
# Vector storing the initial number of people in each compartment (at timestep 0)
initial_state_values <- c(S = (1-p)*(N-1),   # a proportion 1-p of the total population is susceptible
I = 1,             # the epidemic starts with a single infected person
R = p*(N-1))       # a proportion p of the total population is vaccinated/immune
# Solving the differential equations using the ode integration algorithm
output <- as.data.frame(ode(y = initial_state_values,
times = times,
func = sir_model,
parms = parameters))
output_long <- melt(as.data.frame(output), id = "time")                  # turn output dataset into long format
# Adding a column for the prevalence proportion to the long-format output
output_long$prevalence <- output_long$value/sum(initial_state_values)
# Plot the prevalence proportion
ggplot(data = output_long,                                               # specify object containing data to plot
aes(x = time, y = prevalence, colour = variable, group = variable)) +  # assign columns to axes and groups
geom_line() +                                                          # represent data as lines
xlab("Time (days)")+                                                   # add label for x axis
ylab("Prevalence (proportion)") +                                      # add label for y axis
labs(colour = "Compartment",                                           # add legend title
title = "Prevalence of infection, susceptibility and recovery over time")   # add plot title
# Vaccine coverage
p <- 0.72
# Vector storing the initial number of people in each compartment (at timestep 0)
initial_state_values <- c(S = (1-p)*(N-1),   # a proportion 1-p of the total population is susceptible
I = 1,             # the epidemic starts with a single infected person
R = p*(N-1))       # a proportion p of the total population is vaccinated/immune
# Solving the differential equations using the ode integration algorithm
output <- as.data.frame(ode(y = initial_state_values,
times = times,
func = sir_model,
parms = parameters))
output_long <- melt(as.data.frame(output), id = "time")                  # turn output dataset into long format
# Adding a column for the prevalence proportion to the long-format output
output_long$prevalence <- output_long$value/sum(initial_state_values)
# Plot the prevalence proportion
ggplot(data = output_long,                                               # specify object containing data to plot
aes(x = time, y = prevalence, colour = variable, group = variable)) +  # assign columns to axes and groups
geom_line() +                                                          # represent data as lines
xlab("Time (days)")+                                                   # add label for x axis
ylab("Prevalence (proportion)") +                                      # add label for y axis
labs(colour = "Compartment",                                           # add legend title
title = "Prevalence of infection, susceptibility and recovery over time")   # add plot title
>>>>>>> 6182cbec7f93fd3d35fb8a0cd0c7bed112d27662
use_readme_rmd(open = rlang::is_interactive())
library(usethis)
use_readme_rmd(open = rlang::is_interactive())
usethis::use_github_action_check_standard()
usethis::use_github_action_check_standard()
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager") #
library(LEA)
install
knitr::opts_chunk$set(echo = TRUE)
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
?gfData
??gfData
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
library(LEA)
?gfData
#make sure you have installed devtools previously.
#Install the most uptodate version from github
#if (!requireNamespace("devtools", quietly = TRUE))
# install.packages("devtools")
#devtools:: install_github('nfj1380/mrIML')
library(mrIML)
#other package we need:
library(vip); library(tidymodels); library(randomForest);  library(caret); library(gbm);
library(tidyverse);library(parallel); library(doParallel); library(themis); library(viridis); library(janitor); library(hrbrthemes); library(xgboost); library(vegan);library(flashlight);
library(ggrepel)
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("LEA")
#make sure you have installed devtools previously.
#Install the most uptodate version from github
#if (!requireNamespace("devtools", quietly = TRUE))
# install.packages("devtools")
#devtools:: install_github('nfj1380/mrIML')
library(mrIML)
#other package we need:
library(vip); library(tidymodels); library(randomForest);  library(caret); library(gbm);
library(tidyverse);library(parallel); library(doParallel); library(themis); library(viridis); library(janitor); library(hrbrthemes); library(xgboost); library(vegan);library(flashlight);
library(ggrepel)
#library(LEA)
# read in data file with minor allele freqs & env/space variables
gfData; str(gfData)
envGF <- gfData[,3:13] # get climate & MEM variables
Y <- envGF #for simplicity
# build individual SNP datasets
SNPs_ref <- gfData[,grep("REFERENCE",colnames(gfData))] # reference
GI5 <- gfData[,grep("GI5",colnames(gfData))] # GIGANTEA-5 (GI5)
X <- GI5 #for this example we are going to focus on the adaptive SNPs in the GI5 region.
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
gfData; str(gfData)
str()
str
?str\
?str
pkgdown::build_site()
build_home()
build_news()
pkgdown::build_site()
pkgdown::build_site()
library(pkgdown)
pkgdown::build_site()
build_news()
#init_site()
sink()
#init_site()
sink()
build_news()
pkgdown::build_site()
library(pkgdown)
#init_site()
sink()
pkgdown::build_site()
library(pkgdown)
pkgdown::build_site()
usethis::use_github_action("pkgdown")
usethis::use_github_action("pkgdown")
pkgdown::build_site()
getwd()
build_news()
library(pkgdown)
build_home()
pkgdown::build_site()
library(pkgdown)
library(pkgdown)
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
library(mrIML)
remove.packages("mrIML", lib="~/R/win-library/3.6")
devtools::install_github('nfj1380/mrIML')
install.packages("xgboost")
pkgdown::build_site()
library(mrIML)
library(mrIML)
model1 <-
rand_forest(trees = 100, mode = "classification") %>% #100 trees are set for brevity
set_engine("ranger", importance = c("impurity","impurity_corrected")) %>%# select the engine/package that underlies the model
set_mode("classification")# choose either the continuous "regression" or binary "classification" mode
library(mrIML)
#other package needed:
library(vip); library(tidymodels); library(randomForest);  library(caret); library(gbm);
library(tidyverse);library(parallel); library(doParallel); library(themis); library(viridis);
library(janitor); library(hrbrthemes); library(xgboost); library(vegan);library(flashlight);
library(mrIML)
#other package needed:
library(vip); library(tidymodels); library(randomForest);  library(caret); library(gbm);
library(tidyverse);library(parallel); library(doParallel); library(themis); library(viridis);
library(janitor); library(hrbrthemes); library(xgboost);library(flashlight);
library(ggrepel); library(parsnip);library(rsample); library(workflows)
VI <- mrVip(yhats, Y=Y)
detach("package:mrIML", unload = TRUE)
library(mrIML)
VI <- mrVip(yhats, Y=Y)
# Define set of features
FeaturesnoNA<-Features[complete.cases(Features), ]
Y <- FeaturesnoNA #for simplicity
# Define set the outcomes of interst
fData <- filterRareCommon (Responsedata, lower=0.4, higher=0.7)
X <- fData #
yhats <- mrIMLpredicts(X=X,Y=Y, model1=model1, balance_data='no', mod='classification', parallel = TRUE)
model1 <-
rand_forest(trees = 100, mode = "classification") %>% #100 trees are set for brevity
set_engine("ranger", importance = c("impurity","impurity_corrected")) %>%# select the engine/package that underlies the model
set_mode("classification")# choose either the continuous "regression" or binary "classification" mode
data <- gfData[1:20]
head(data)
# Define set of features
FeaturesnoNA<-Features[complete.cases(Features), ]
Y <- FeaturesnoNA #for simplicity
# Define set the outcomes of interst
fData <- filterRareCommon (Responsedata, lower=0.4, higher=0.7)
X <- fData #
yhats <- mrIMLpredicts(X=X,Y=Y, model1=model1, balance_data='no', mod='classification', parallel = TRUE)
#save(yhats, file='logreg_model')
ModelPerf <- mrIMLperformance(yhats, model1, X=X) #
ModelPerf[[2]]
VI <- mrVip(yhats, Y=Y)
plot_vi(VI=VI,  X=X,Y=Y, modelPerf=ModelPerf, cutoff= 0, plot.pca='yes') #the cutoff reduces the number of individual models printed in the second plot.
pkgdown::build_site()
20216+4198
25000-24414
13*30
30+36+4+4
74*13
20216+4198+586
100*40
4000*4
16000*12
20*100
2000*4
devtools::session_info()
360/5
25+45+80
25+45+80+50+50
25+45+80+50+80
35+45+80+50+80
35+75+80+50+80
35+75+80+60+80
35+75+80+70+80
45+75+80+70+80
45+75+85+70+80
45+75+85+75+80
30/5
30/54
30/4
30/2
30/3
30/4
6*5
