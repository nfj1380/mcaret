y_features = 'Microfilaria',
kind = "beeswarm",
max_display = 5,
interactions = F,
getFeaturePlot=T,
getDependencyPlot=T,
getInteractionPlot=T,
num_cores =6,
class_selection =1)
shapTest <- MrShapely(yhats_rf,MultRespVars=X1,
#taxa=3:4,
x_features= "Plas",
y_features = 'Microfilaria',
kind = "beeswarm",
max_display = 5,
interactions = F,
getFeaturePlot=T,
getDependencyPlot=T,
getInteractionPlot=T,
num_cores =6,
class_selection =1)
shapTest <- MrShapely(yhats_rf,MultRespVars=X1,
taxa=1,
x_features= "Plas",
y_features = 'Microfilaria',
kind = "beeswarm",
max_display = 5,
interactions = F,
getFeaturePlot=T,
getDependencyPlot=T,
getInteractionPlot=T,
num_cores =6,
class_selection =1)
shapTest <- MrShapely(yhats_rf,MultRespVars=X1,
taxa=3,
x_features= "Plas",
y_features = 'Microfilaria',
kind = "beeswarm",
max_display = 5,
interactions = F,
getFeaturePlot=T,
getDependencyPlot=T,
getInteractionPlot=T,
num_cores =6,
class_selection =1)
shapTest <- MrShapely(yhats_rf,MultRespVars=X1,
taxa=2,
x_features= "Plas",
y_features = 'Microfilaria',
kind = "beeswarm",
max_display = 5,
interactions = T,
getFeaturePlot=T,
getDependencyPlot=T,
getInteractionPlot=T,
num_cores =6,
class_selection =1)
library(ParBayesianOptimization)
library(DALEX)
library(ingredients)
library(mrIML)
library(tidymodels)
library(tidyr)
library(tidyverse)
library(shapr)
library(shapviz)
library(cowplot)
library(gridExtra)
library(future.apply)
library(future)
library(ggplot2)
library(svMisc)
library(kernelshap)
library(doParallel)
library("ggplotify")
shapTest <- MrShapely(yhats_rf,MultRespVars=X1,
taxa=2,
x_features= "Plas",
y_features = 'Microfilaria',
kind = "beeswarm",
max_display = 5,
interactions = T,
getFeaturePlot=T,
getDependencyPlot=T,
getInteractionPlot=T,
num_cores =6,
class_selection =1)
shapTest <- MrShapely(yhats_rf,MultRespVars=X1,
taxa=1,
x_features= "Plas",
y_features = 'Microfilaria',
kind = "beeswarm",
max_display = 5,
interactions = T,
getFeaturePlot=T,
getDependencyPlot=T,
getInteractionPlot=T,
num_cores =6,
class_selection =1)
shapTest <- MrShapely(yhats_rf,MultRespVars=X1,
taxa=2,
x_features= "Plas",
y_features = 'Microfilaria',
kind = "beeswarm",
max_display = 5,
interactions = F,
getFeaturePlot=T,
getDependencyPlot=T,
getInteractionPlot=T,
num_cores =6,
class_selection =1)
shapTest <- MrShapely(yhats_rf,MultRespVars=X1,
taxa=1,
x_features= "Plas",
y_features = 'Microfilaria',
kind = "beeswarm",
max_display = 5,
interactions = F,
getFeaturePlot=T,
getDependencyPlot=T,
getInteractionPlot=T,
num_cores =6,
class_selection =1)
#---------------------------------------------------------------------------------
#coinfection test data # from MRFcov. This data can also be used in this pipeline replacing X/Y
#---------------------------------------------------------------------------------
pacman::p_load('MRFcov', 'mrIML', 'tidyverse', 'future.apply','tidymodels', 'finetune',
'themis', 'vip', 'flashlight', 'iml', 'vivid', 'igraph', 'ggnetwork', 'network',
'gridExtra', 'xgboost', 'brulee', 'fastshap', 'tabnet', 'bonsai',
'parsnip', 'cowplot', 'progress', 'hstats')
source("MrIMLpredicts.R")
pacman::p_load('MRFcov', 'mrIML', 'tidyverse', 'future.apply','tidymodels', 'finetune',
'themis', 'vip', 'flashlight', 'iml', 'vivid', 'igraph', 'ggnetwork', 'network',
'gridExtra', 'xgboost', 'brulee', 'fastshap', 'tabnet', 'bonsai',
'parsnip', 'cowplot', 'progress', 'hstats')
Y <- dplyr::select(Bird.parasites, -scale.prop.zos)%>%
dplyr::select(sort(names(.)))#response variables eg. SNPs, pathogens, species....
X <- dplyr::select(Bird.parasites, scale.prop.zos) # feature set
X1 <- Y %>%
dplyr::select(sort(names(.)))
X1_fact <- X1 %>%
mutate_all(as.factor) %>%
mutate_all(~ifelse(. == 0, "absent", "present"))
#model setup
model_rf <-
rand_forest(trees = 100, mode = "classification", mtry = tune(), min_n = tune()) %>% #100 trees are set for brevity. Aim to start with 1000
set_engine("randomForest")
cl <- parallel::makeCluster(5)
plan(cluster, workers=cl)
#
################################
#Configuring the model
################################
#Can try different combinations of things here. With and without X1 (taxa assocations)
#With Xsp (spatial eigenvectors) and X (enviro/host variables) combined or sepparated
#compare performance across all data and a few differing algorithms
yhats_rf <- mrIMLpredicts(X=X, Y=Y,
X1=X1,
Model=model_rf , #lm/xgb not working on avian malaria
balance_data='no',
mode='classification',
tune_grid_size=5,
seed = sample.int(1e8, 1),
#      morans=F,
prop=0.7, k=5, racing=T)
#####################################################################################
#[1]CORE FUNCTION
######################################################################################
#' Generate SHAP (SHapley Additive exPlanations) Plots for Multiple Models and Responses
#'
#' This function generates SHAP (SHapley Additive exPlanations) plots for multiple models and responses.
#'
#' @param yhats A list of model prediction objects. Each object should contain a model, data, and class information.
#' @param MultRespVars A data frame containing response variables for the prediction.
#' @param taxa An optional vector specifying which responses to include based on their indices.
#' @param x_features A character vector specifying the features to consider in the plots.
#' @param y_features A character vector specifying the response features for interaction plots.
#' @param kind A character string specifying the type of plots (e.g., "beeswarm" for feature effect plot, "bar" for variable importance plot, or "both").
#' @param max_display An integer specifying the maximum number of features to display.
#' @param interactions A logical indicating whether to create interaction effect plots.
#' @param color_var A variable to use for coloring in the dependency plots.
#' @param getFeaturePlot A logical indicating whether to generate feature effect plots.
#' @param getDependencyPlot A logical indicating whether to generate dependency plots.
#' @param getInteractionPlot A logical indicating whether to generate interaction plots.
#' @param num_cores An integer specifying the number of CPU cores to use for parallel processing.
#' @param class_selection An optional vector specifying which classes to include in the plots.
#'
#' @return A ggplot object containing SHAP plots for the specified responses and features.
#'
#' @examples
#' # Example usage:
#' MrShapely(yhats, MultRespVars = Resp)
#' @export
MrShapely <- function(yhats, MultRespVars = Resp,
taxa = NULL, x_features = NULL,
y_features = NULL, kind = "beeswarm",
max_display = 15L, interactions = FALSE,
color_var = NULL, getFeaturePlot = TRUE,
getDependencyPlot = TRUE, getInteractionPlot = TRUE,
num_cores = 2,
class_selection = NULL) {
# Parallelization
plan(future::multisession, workers = num_cores)
# Extract model, data, and response information
mod_list <- future_lapply(yhats, function(yhat) yhat$mod1_k,future.seed = TRUE)
model_list <-lapply(mod_list, extract_fit_parsnip)#This part does not seem to work with future_lapply
Xdata_list <- future_lapply(yhats, function(yhat) as.data.frame(yhat$data),future.seed = TRUE)
X_i_list <- future_lapply(yhats, function(yhat) as.data.frame(select(yhat$data, -class)),future.seed = TRUE)
Y_i_list <- future_lapply(yhats, function(yhat) yhat$data$class,future.seed = TRUE)
# Calculate Shap_kernel and shapobj for all responses using future_lapply
shapobj_list <- future_lapply(1:length(model_list), function(i) {
model <- model_list[[i]]
X_i <- X_i_list[[i]]
Xdata <- Xdata_list[[i]]
Y_i <- Y_i_list[[i]]
# Deals with classification cases
if (model$spec$mode == "classification") {
predfun <- function(model, newdata) {
preds <- predict(model, as.data.frame(newdata), type = 'response') # probabilities
return(cbind(1 - preds, preds)) # for both classes
}
if (inherits(model$fit, "glm")) {
Shap_kernel <- kernelshap(model$fit, X = X_i,
pred_fun = predfun,
bg_X = Xdata)
shapobj <- shapviz(Shap_kernel)
names(shapobj) <- levels(Y_i)
} else if (inherits(model$fit, "randomForest") || inherits(model$fit, "ranger")) {
Shap_kernel <- kernelshap(model, X = X_i,
bg_X = Xdata,
type = "prob")
shapobj <- shapviz(Shap_kernel)
names(shapobj) <- levels(Y_i)
} else {
shapobj <- shapviz(model$fit,
X_pred = data.matrix(X_i),
X = Xdata,
interactions = FALSE)
names(shapobj) <- levels(Y_i)
}
return(shapobj)
}
# Deals with regression cases
if (model$spec$mode == "regression") {
if (inherits(model$fit, "lm")) {
Shap_kernel <- kernelshap(model$fit, X = X_i,
bg_X = Xdata)
shapobj <- shapviz(Shap_kernel)
} else if (inherits(model$fit, "randomForest") || inherits(model$fit, "ranger")) {
Shap_kernel <- kernelshap(model, X = X_i,
bg_X = Xdata)
shapobj <- shapviz(Shap_kernel)
} else {
shapobj <- shapviz(model$fit,
X_pred = data.matrix(X_i),
interactions = FALSE)
}
return(shapobj)
}
},future.seed = TRUE)
# Subset the results based on the 'taxa' parameter
if (!is.null(taxa)) {
if (is.numeric(taxa)) {
if (length(taxa) == 1) {
print("Subset shapobj_list based on 'taxa'.")
shapobj_list <- list(shapobj_list[[taxa]])
ResponseNames <- colnames(MultRespVars)[taxa]
} else if (length(taxa) > 0 && all(taxa > 0 & taxa <= length(shapobj_list))) {
print("Subset shapobj_list based on 'taxa'.")
shapobj_list <- shapobj_list[taxa]
ResponseNames <- colnames(MultRespVars)[taxa]
} else {
stop("Invalid value for 'taxa'. Please provide valid indices.")
}
} else {
stop("Invalid value for 'taxa'. Please provide numeric indices.")
}
} else {
ResponseNames <- colnames(MultRespVars)
taxa <- seq_along(shapobj_list)
}
# Initialize an empty list to store plots with labels
plots_with_labels <- list()
# [1] FEATURE EFFECT PLOT FUNCTION
if (isTRUE(getFeaturePlot)) {
if (is.null(taxa)) {
taxa_to_iterate <- seq_along(shapobj_list)
} else if (length(taxa) > 1) {
taxa_to_iterate <- taxa
} else {
taxa_to_iterate <- 1
}
feature_plots_with_labels <- future_lapply(taxa_to_iterate, function(i) {
print(paste("Processing index:", i))
response_name <- ifelse(is.null(ResponseNames[i]), "", ResponseNames[i])
if (model_list[[i]]$spec$mode == "regression") {
label <- response_name
shapobj <- shapobj_list[[i]]
print(paste("Index:", i, "Length of shapobj_list:", length(shapobj_list)))
plot_obj <- sv_importance(shapobj, kind = kind, max_display = max_display) + labs(title = label)
} else {
class_list <- shapobj_list[[i]]
print(paste("Index:", i, "Length of shapobj_list:", length(shapobj_list)))
class_feature_plots <- future_lapply(names(class_list), function(class_name) {
if (!is.null(class_selection) && !(class_name %in% class_selection)) {
return(NULL)
}
class_obj <- class_list[[class_name]]
label <- ifelse(is.null(class_name), response_name, paste(response_name, class_name, sep = " - "))
plot_obj <- sv_importance(class_obj, kind = kind, max_display = max_display) + labs(title = label)
return(plot_obj)
},future.seed = TRUE)
class_feature_plots <- class_feature_plots[!future_sapply(class_feature_plots, is.null)]
if (length(class_feature_plots) > 0) {
return(do.call(gridExtra::grid.arrange, class_feature_plots))
} else {
return(NULL)
}
}
},future.seed = TRUE)
plots_with_labels <- c(plots_with_labels, feature_plots_with_labels)
}
# END OF FEATURE EFFECT PLOT FUNCTION
# [2] DEPENDENCY PLOT FUNCTION
if (isTRUE(getDependencyPlot)) {
dependency_plots_with_labels <- future_lapply(1:length(shapobj_list), function(i) {
response_name <- ifelse(is.null(ResponseNames[i]), "", ResponseNames[i])
if (model_list[[i]]$spec$mode == "regression") {
label <- response_name
shapobj <- shapobj_list[[i]]
dependency_plots <- future_lapply(x_features, function(x_feature) {
plot_obj <- sv_dependence(shapobj, x_feature, color_var = NULL) + labs(title = label)
return(plot_obj)
})
ncol <- length(x_features)
arranged_plots <- do.call(gridExtra::grid.arrange, c(dependency_plots, ncol = ncol))
return(arranged_plots)
} else {
class_list <- shapobj_list[[i]]
class_dependency_plots <- future_lapply(names(class_list), function(class_name) {
if (!is.null(class_selection) && !(class_name %in% class_selection)) {
return(NULL)
}
class_obj <- class_list[[class_name]]
label <- ifelse(is.null(class_name), response_name, paste(response_name, class_name, sep = " - "))
dependency_plots <- future_lapply(x_features, function(x_feature) {
plot_obj <- sv_dependence(class_obj, x_feature, color_var = NULL) + labs(title = label)
return(plot_obj)
},future.seed = TRUE)
ncol <- length(x_features)
arranged_plots <- do.call(gridExtra::grid.arrange, c(dependency_plots, ncol = ncol))
return(arranged_plots)
},future.seed = TRUE)
class_dependency_plots <- class_dependency_plots[!future_sapply(class_dependency_plots, is.null)]
if (length(class_dependency_plots) > 0) {
return(do.call(gridExtra::grid.arrange, class_dependency_plots))
} else {
return(NULL)
}
}
},future.seed = TRUE)
plots_with_labels <- c(plots_with_labels, dependency_plots_with_labels)
}
print("After dependency plots.")
# END OF DEPENDENCY PLOT FUNCTION
# [3] INTERACTION EFFECT PLOT FUNCTION
if (isTRUE(getInteractionPlot)) {
interaction_plots_with_labels <- future_lapply(1:length(shapobj_list), function(i) {
response_name <- ifelse(is.null(ResponseNames[i]), "", ResponseNames[i])
if (model_list[[i]]$spec$mode == "regression") {
label <- response_name
shapobj <- shapobj_list[[i]]
interaction_plots <- future_lapply(y_features, function(y_feature) {
interaction_label <- paste(response_name, sep = " - ")
interaction_plot <- sv_dependence2D(shapobj, x_features, y_feature, interactions = interactions) + labs(title = interaction_label)
return(interaction_plot)
})
return(do.call(gridExtra::grid.arrange, interaction_plots))
} else {
class_list <- shapobj_list[[i]]
interaction_plots <- list()
for (y_feature in y_features) {
interaction_plots_for_feature <- future_lapply(names(class_list), function(class_name) {
if (!is.null(class_selection) && !(class_name %in% class_selection)) {
return(NULL)
}
class_obj <- class_list[[class_name]]
interaction_label <- paste(response_name, class_name, sep = " - ")
interaction_plot <- sv_dependence2D(class_obj, x_features, y_feature, interactions = interactions) + labs(title = interaction_label)
return(interaction_plot)
},future.seed = TRUE)
interaction_plots_for_feature <- interaction_plots_for_feature[!future_sapply(interaction_plots_for_feature, is.null)]
interaction_plots <- c(interaction_plots, interaction_plots_for_feature)
}
if (length(interaction_plots) > 0) {
return(do.call(gridExtra::grid.arrange, interaction_plots))
} else {
return(NULL)
}
}
},future.seed = TRUE)
plots_with_labels <- c(plots_with_labels, interaction_plots_with_labels)
}
print("After interaction plots.")
# END OF INTERACTION EFFECT PLOT FUNCTION
# Stop parallel processing
future::plan(future::sequential)
ncol <- max(1, ceiling(sqrt(length(plots_with_labels))))
# Create the final plot by stacking responses
final_plot <- do.call(gridExtra::grid.arrange, c(plots_with_labels, ncol = ncol))
final.plot <- as.ggplot(final_plot)
if (getFeaturePlot) {
if (kind == "beeswarm") {
final.plot <- final.plot +
labs(title="Feature Effect Plot")+
theme(plot.title.position = "plot")
} else if (kind == "bar") {
final.plot <- final.plot +
labs(title="Feature Importance Plot")+
theme(plot.title.position = "plot")
} else if (kind == "both") {
final.plot <- final.plot +
labs(title="Feature Effect and Importance Plot")+
theme(plot.title.position = "plot")
}
}
if (getDependencyPlot) {
final.plot <- final.plot +
labs(title="Dependency Plot")+
theme(plot.title.position = "plot")
}
if (getInteractionPlot) {
final.plot <- final.plot +
labs(title="Interaction Effect Plot")+
theme(plot.title.position = "plot")
}
return(final.plot)
}
shapTest=MrShapely(yhats_rf, MultRespVars = X1,
taxa = 2, # taxa=NULL, taxa=1:2 or 1:3 or 1:4, and taxa=1 or 2 or 3 or 4 will only work if only getFeaturePlot = T and rest is false
y_features = c("Plas","Hkillangoi"), #feature set here should be different from taxa for JSDM
x_features = c("Microfilaria"),#, "Hzosteropis","Plas"),
#x_features= c("Microfilaria", "Hzosteropis","Plas") # features here should be different from taxa for for JSDM
kind = "both",
max_display = 4L,
interactions = FALSE, #keep false and only use and set to true for Xgboost
num_cores = 6,
class_selection = 1,
getFeaturePlot = T,
getDependencyPlot = T,
getInteractionPlot = T)
shapTest=MrShapely(yhats_rf, MultRespVars = X1,
taxa = 1:4, # taxa=NULL, taxa=1:2 or 1:3 or 1:4, and taxa=1 or 2 or 3 or 4 will only work if only getFeaturePlot = T and rest is false
y_features = c("Plas","Hkillangoi"), #feature set here should be different from taxa for JSDM
x_features = c("Microfilaria"),#, "Hzosteropis","Plas"),
#x_features= c("Microfilaria", "Hzosteropis","Plas") # features here should be different from taxa for for JSDM
kind = "both",
max_display = 4L,
interactions = FALSE, #keep false and only use and set to true for Xgboost
num_cores = 6,
class_selection = 1,
getFeaturePlot = T,
getDependencyPlot = T,
getInteractionPlot = T)
shapTest=MrShapely(yhats_rf, MultRespVars = X1,
taxa = 1:3, # taxa=NULL, taxa=1:2 or 1:3 or 1:4, and taxa=1 or 2 or 3 or 4 will only work if only getFeaturePlot = T and rest is false
y_features = c("Plas","Hkillangoi"), #feature set here should be different from taxa for JSDM
x_features = c("Microfilaria"),#, "Hzosteropis","Plas"),
#x_features= c("Microfilaria", "Hzosteropis","Plas") # features here should be different from taxa for for JSDM
kind = "both",
max_display = 4L,
interactions = FALSE, #keep false and only use and set to true for Xgboost
num_cores = 6,
class_selection = 1,
getFeaturePlot = T,
getDependencyPlot = T,
getInteractionPlot = T)
shapTest=MrShapely(yhats_rf, MultRespVars = X1,
#taxa = 1:3, # taxa=NULL, taxa=1:2 or 1:3 or 1:4, and taxa=1 or 2 or 3 or 4 will only work if only getFeaturePlot = T and rest is false
y_features = c("Plas","Hkillangoi"), #feature set here should be different from taxa for JSDM
x_features = c("Microfilaria"),#, "Hzosteropis","Plas"),
#x_features= c("Microfilaria", "Hzosteropis","Plas") # features here should be different from taxa for for JSDM
kind = "both",
max_display = 4L,
interactions = FALSE, #keep false and only use and set to true for Xgboost
num_cores = 6,
class_selection = 1,
getFeaturePlot = T,
getDependencyPlot = T,
getInteractionPlot = T)
shapTest=MrShapely(yhats_rf, MultRespVars = X1,
#taxa = 1:3, # taxa=NULL, taxa=1:2 or 1:3 or 1:4, and taxa=1 or 2 or 3 or 4 will only work if only getFeaturePlot = T and rest is false
y_features = c("Plas","Hkillangoi"), #feature set here should be different from taxa for JSDM
x_features = c("Microfilaria"),#, "Hzosteropis","Plas"),
#x_features= c("Microfilaria", "Hzosteropis","Plas") # features here should be different from taxa for for JSDM
kind = "both",
max_display = 4L,
interactions = FALSE, #keep false and only use and set to true for Xgboost
num_cores = 6,
class_selection = 1,
getFeaturePlot = T,
getDependencyPlot = F,
getInteractionPlot = F)
devtools::document()
rm(list = c("MrShapely"))`
)
''
'
''
``
rm(list = c("MrShapely"))
devtools::document()
