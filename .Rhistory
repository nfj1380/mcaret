local_top_var=2)
bs_impVIa1[[2]]
pds <- mrPD_bootstrap(mrBootstrap_obj=bs_ostrich, vi_obj=bs_impVIa1, X, Y,
target='Bact_16.1', global_top_var=5)
int_ <- mrInteractions(yhats=yhats_rf, X, Y, num_bootstrap=5,
feature = 'Bact_16.1', top.int=10)
#' Calculate and visualize feature interactions
#'
#' This function calculates and visualizes interactions in the model using bootstrapping.
#' It provides overall, one-way, and two-way interactions for specified features.
#'
#' @param yhats A list of model predictions.
#' @param X The predictor data.
#' @param Y The response data.
#' @param num_bootstrap The number of bootstrap samples to generate (default: 1).
#' @param feature The feature for which interactions need to be calculated.
#' @param top.int The number of top interactions to display (default: 10).
#'
#' @return A list containing the visualizations for overall, one-way, and two-way interactions, as well as the interaction dataframes.
#' @export
#'
#' @examples
#' \dontrun{
#' # Example usage:
#' #set up analysis
#' Y <- dplyr::select(Bird.parasites, -scale.prop.zos)%>%
#' dplyr::select(sort(names(.)))#response variables eg. SNPs, pathogens, species....
#' X <- dplyr::select(Bird.parasites, scale.prop.zos) # feature set
#' X1 <- Y %>%
#' dplyr::select(sort(names(.)))
#'model_rf <-
#' rand_forest(trees = 100, mode = "classification", mtry = tune(), min_n = tune()) %>% #100 trees are set for brevity. Aim to start with 1000
#' set_engine("randomForest")
#' yhats_rf <- mrIMLpredicts(X=X, Y=Y,
#'X1=X1,'Model=model_rf ,
#'balance_data='no',mode='classification',
#'tune_grid_size=5,seed = sample.int(1e8, 1),'morans=F,
#'prop=0.7, k=5, racing=T)
#'int_ <- mrInteractions(yhats=yhats_rf, X, Y, num_bootstrap=10,
#'feature = 'Microfilaria', top.int=10)
#'int_[[1]] # overall plot
#'int_[[2]] # individual plot for the response of choice
#'int_[[3]] #two way plot# }
mrInteractions <- function (yhats, X, Y, num_bootstrap = 1, feature = feature, top.int = 10) {
{
n_response <- length(yhats)
pb <- txtProgressBar(min = 0, max = n_response, style = 3)
internal_fit_function <- function(k) {
setTxtProgressBar(pb, k)
features <- colnames(yhats[[k]]$data)[-1]
n <- nrow(yhats[[k]]$data)
int_raw <- list()
if (is.na(num_bootstrap) || num_bootstrap == 1) {
bootstrap_sample <- yhats[[k]]$data
}
for (i in 1:num_bootstrap) {
if (num_bootstrap > 1) {
bootstrap_sample <- yhats[[k]]$data[sample(1:n, replace = TRUE), ]
wflow <- yhats[[k]]$last_mod_fit %>% tune::extract_workflow()
wflow$data <- bootstrap_sample
model_fit <- fit(wflow, data = bootstrap_sample)
}
else {
model_fit <- yhats[[k]]$mod1_k %>% extract_fit_parsnip()
}
metrics <- list(logloss = MetricsWeighted::logLoss,
`ROC AUC` = MetricsWeighted::AUC, `% Dev Red` = MetricsWeighted::r_squared_bernoulli)
var_names <- names(yhats[[k]]$data)[-1]
pred_fun <- function(m, dat) {
predict(m, dat[, colnames(bootstrap_sample)[-1], drop = FALSE], type = "prob")$.pred_1
}
s <- hstats(model_fit, v = names(yhats[[k]]$data_train)[-1],
X = yhats[[k]]$data_train, pred_fun = pred_fun,
n_max = 300, pairwise_m = length(names(yhats[[k]]$data_train)[-1]),
threeway_m = 0, verbose = F)
overall <- data.frame(response = names(Y[k]), overall = h2(s)[[1]],
bs = i)
one_way <- data.frame(one_way=h2_overall(s, plot = FALSE)[[1]]) %>%
rownames_to_column("predictor")
metadata <- data.frame(response = rep(names(Y[k]),
nrow(one_way)), bstrap = rep(i, nrow(one_way)))
one_way_df <- cbind(one_way, metadata)
two_way <- data.frame(two_way_int=h2_pairwise(s, plot = FALSE)[[1]])%>%
rownames_to_column("predictor") #top_m = inf)
meta_data2 <- data.frame(response = rep(names(Y[k])),
bstrap = rep(i, nrow(two_way)))
two_way_df <- cbind(two_way, meta_data2)
interaction_objects <- list(overall_int = overall,
one_way_int = one_way_df, two_way_int = two_way_df)
int_raw[[i]] <- interaction_objects
}
return(int_raw)
}
bstraps_int_list <- future_lapply(seq(1, n_response), internal_fit_function,
future.seed = TRUE)
bs_list_overall <- lapply(bstraps_int_list, function(sublist) {
extracted_overall_int <- map(sublist, pluck, "overall_int")
do.call(rbind, extracted_overall_int)
})
overall_int_final <- do.call(rbind, bs_list_overall)
top_int_overall <- overall_int_final %>% group_by(response) %>%
summarize(avg_Int = mean(overall), .groups = "drop")
top_int_overall_ordered <- top_int_overall %>% arrange(desc(avg_Int)) %>%
dplyr::slice(1:top.int)
top_names <- top_int_overall_ordered$response
overall_int_final_top <- overall_int_final %>% dplyr::filter(response %in%
top_names)
p1 <- ggplot(overall_int_final_top, aes(x = reorder(response,
-overall), y = overall)) + geom_boxplot() + labs(title = "Overall interactions",
x = "Response", y = "Overall") + theme_bw()
bs_list_one_way <- lapply(bstraps_int_list, function(sublist) {
extracted_one_way_int <- map(sublist, pluck, "one_way_int")
do.call(rbind, extracted_one_way_int)
})
overall_one_way_final <- do.call(rbind, bs_list_one_way)
filtered_one_way <- overall_one_way_final %>% dplyr::filter(response ==
feature)
top_int_one_way <- filtered_one_way %>% group_by(response,
predictor) %>% summarize(avg_Int = mean(one_way), .groups = "drop")
top_int_one_way_ordered <- top_int_one_way %>% arrange(desc(avg_Int)) %>%
dplyr::slice(1:top.int)
top_names_one_way <- top_int_one_way_ordered$predictor
one_way_int_final_top <- filtered_one_way %>% dplyr::filter(predictor %in%
top_names_one_way)
p2 <- ggplot(one_way_int_final_top, aes(x = reorder(predictor,
-one_way), y = one_way)) + geom_boxplot() + labs(title = paste(feature,
"one-way interactions", sep = " "), x = feature, y = paste(feature,
"interaction importance", sep = " ")) + theme_bw()
avg_v_by_response <- overall_one_way_final %>% group_by(response,
predictor) %>% summarize(avg_oneway = mean(one_way), .groups = "drop") %>%
arrange(desc(avg_oneway)) %>% dplyr::slice(1:top.int)
p2_com <- ggplot(avg_v_by_response, aes(x = reorder(predictor,
-avg_oneway), y = avg_oneway)) + geom_boxplot() + labs(title = "Community-level one-way interactions",
x = "Predictors", y = "Community interaction importance") +
theme_bw()
combined_plot_one_way <- plot_grid(p2, p2_com, ncol = 2)
bs_list_two_way <- lapply(bstraps_int_list, function(sublist) {
extracted_two_way_int <- map(sublist, pluck, "two_way_int")
do.call(rbind, extracted_two_way_int)
})
overall_two_way_final <- do.call(rbind, bs_list_two_way)
filtered_two_way <- overall_two_way_final %>% dplyr::filter(response ==
feature)
top_int_two_way <- filtered_two_way %>% group_by(response,
predictor) %>% summarize(avg_Int2 = mean(two_way_int), .groups = "drop")
top_int_two_way_ordered <- top_int_two_way %>% arrange(desc(avg_Int2)) %>%
dplyr::slice(1:top.int)
top_names_two_way <- top_int_two_way_ordered$predictor
two_way_int_final_top <- filtered_two_way %>% filter(predictor %in%
top_names_two_way)
p3 <- ggplot(two_way_int_final_top, aes(x = reorder(predictor,
-two_way_int ), y = two_way_int )) + geom_boxplot() + labs(title = paste(feature,
"two-way interactions", sep = " "), x = feature, y = paste(feature,
"interaction importance", sep = " ")) + theme_bw() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
avg_v_by_response_two_way <- overall_two_way_final %>% group_by(response,
predictor) %>% summarize(avg_twoway = mean(two_way_int), .groups = "drop") %>%
dplyr::slice(1:top.int)
p3_com <- ggplot(avg_v_by_response_two_way, aes(x = reorder(predictor,
- avg_twoway ), y =  avg_twoway )) + geom_boxplot() + labs(title = "Community-level two-way interactions",
x = "Predictors", y = "Community interaction importance") +
theme_bw() + theme(axis.text.x = element_text(angle = 45,
hjust = 1))
combined_plot_two_way <- plot_grid(p3, p3_com, ncol = 2)
return(list(p1, combined_plot_one_way, combined_plot_two_way,
overall_int_final, overall_one_way_final, overall_two_way_final))
}
}
int_ <- mrInteractions(yhats=yhats_rf, X, Y, num_bootstrap=5,
feature = 'Bact_16.1', top.int=10)
int_[[1]]
int_[[2]]
int_[[3]]
assoc_net<- mrCoOccurNet_bootstrap (mrPD_obj=bs_ostrich , Y=Y)
assoc_net<- mrCoOccurNet_bootstrap (mrPD_obj=bs_ostrich , Y=Y)
yhats_rf_noX <- mrIMLpredicts(X=NULL, Y=Y,
X1=X1,
Model=model_rf , #lm/xgb not working on avian malaria
balance_data='no',
mode='classification',
tune_grid_size=5,
seed = sample.int(1e8, 1),
morans=F,
prop=0.7, k=5, racing=T)
m <- ModelPerf[[1]]
write.csv(m, 'IleumPerfCombined')
ModelPerf <- mrIMLperformance(yhats_rf_noX, Model=model_rf, Y=Y, mode='classification')
m <- ModelPerf[[1]]
write.csv(m, 'IleumPerfNoX')
ModelPerf
ModelPerf <- mrIMLperformance(yhats_rf, Model=model_rf, Y=Y, mode='classification')
ModelPerf
yhats_rf_noX1 <- mrIMLpredicts(X=X, Y=Y,
X1=NULL,
Model=model_rf , #lm/xgb not working on avian malaria
balance_data='no',
mode='classification',
tune_grid_size=5,
seed = sample.int(1e8, 1),
morans=F,
prop=0.7, k=5, racing=T)
ModelPerf <- mrIMLperformance(yhats_rf_noX1, Model=model_rf, Y=Y, mode='classification')
ModelPerf
m <- ModelPerf[[1]]
write.csv(m, 'IleumPerfNoX1')
model_rf <-
rand_forest(trees = 1000, mode = "classification", mtry = tune(), min_n = tune()) %>% #100 trees are set for brevity. Aim to start with 1000
set_engine("randomForest")
yhats_rf <- mrIMLpredicts(X=X, Y=Y,
X1=X1,
Model=model_rf , #lm/xgb not working on avian malaria
balance_data='no',
mode='classification',
tune_grid_size=5,
seed = sample.int(1e8, 1),
morans=F,
prop=0.7, k=5, racing=T)
ModelPerf <- mrIMLperformance(yhats_rf, Model=model_rf, Y=Y, mode='classification')
ModelPerf
write.csv(m, 'IleumPerfCombined')
yhats_rf_noX1 <- mrIMLpredicts(X=X, Y=Y,
X1=NULL,
Model=model_rf , #lm/xgb not working on avian malaria
balance_data='no',
mode='classification',
tune_grid_size=5,
seed = sample.int(123),
morans=F,
prop=0.7, k=5, racing=T)
ModelPerf <- mrIMLperformance(yhats_rf_noX1, Model=model_rf, Y=Y, mode='classification')
ModelPerf
yhats_rf_noX1 <- mrIMLpredicts(X=X, Y=Y,
X1=NULL,
Model=model_rf , #lm/xgb not working on avian malaria
balance_data='no',
mode='classification',
tune_grid_size=5,
seed = 123,
morans=F,
prop=0.6, k=5, racing=T)
ModelPerf <- mrIMLperformance(yhats_rf_noX1, Model=model_rf, Y=Y, mode='classification')
ModelPerf
m <- ModelPerf[[1]]
write.csv(m, 'IleumPerfnoX')
yhats_rf_noX <- mrIMLpredicts(X=NULL, Y=Y,
X1=X1,
Model=model_rf ,
balance_data='no',
mode='classification',
tune_grid_size=5,
seed = 123,
morans=F,
prop=0.6, k=5, racing=T)
ModelPerf <- mrIMLperformance(yhats_rf_noX, Model=model_rf, Y=Y, mode='classification')
m <- ModelPerf[[1]]
ModelPerf[[2]]
write.csv(m, 'IleumPerfnoX')
ModelPerf <- mrIMLperformance(yhats_rf_noX1, Model=model_rf, Y=Y, mode='classification')
m <- ModelPerf[[1]]
write.csv(m, 'IleumPerfnoX1')
gc()
assoc_net<- mrCoOccurNet_bootstrap (mrPD_obj=bs_ostrich , Y=Y)
assoc_net<- mrCoOccurNet_bootstrap (mrPD_obj=pds , Y=Y)
assoc_net_filtered <-  assoc_net %>%
filter(mean_strength > 0.05)
g <- graph_from_data_frame(assoc_net_filtered, directed=TRUE)#, vertices=names(Y)) #matching Y data
#undirected
g1 <- graph_from_data_frame(assoc_net_filtered, directed=F)#
#need to fix this - reformat the dataframe
plot(g1, vertex.label=NA,  vertex.size=1, edge.color = E(g)$Color,
edge.width=E(g)$Value, layout=nmds_layout)
ggplot(gg, aes(x = x, y = y, xend = xend, yend = yend)) +
geom_edges(aes(color = Color, linewidth = (mean_strength))) + #makes arrows bigger
geom_nodes(color = "gray", size = degree(g, mode = "out"))+#, fill='black', stroke =2) +
scale_color_identity() +
theme_void() +
theme(legend.position = "none")
gg <- ggnetwork(g)
ggplot(gg, aes(x = x, y = y, xend = xend, yend = yend)) +
geom_edges(aes(color = Color, linewidth = (mean_strength)), curvature = 0.0,
arrow = arrow(length = unit(5, "pt"), type = "closed")) + #makes arrows bigger
geom_nodes(color = "gray", size = degree(g, mode = "out"))+#, fill='black', stroke =2) +
scale_color_identity() +
theme_void() +
theme(legend.position = "none")  +
geom_nodelabel_repel(aes(label = name),
#box.padding = unit(0.5, "lines"),
data = gg,
size=2,
segment.colour = "black",
colour = "white", fill = "grey36")
E(g)$Value <- assoc_net_filtered$mean_strength###chnge this as needed
E(g)$Color <- ifelse(assoc_net_filtered$direction == "negative", "blue", "red")
ggplot(gg, aes(x = x, y = y, xend = xend, yend = yend)) +
geom_edges(aes(color = Color, linewidth = (mean_strength)), curvature = 0.0,
arrow = arrow(length = unit(5, "pt"), type = "closed")) + #makes arrows bigger
geom_nodes(color = "gray", size = degree(g, mode = "out"))+#, fill='black', stroke =2) +
scale_color_identity() +
theme_void() +
theme(legend.position = "none")  +
geom_nodelabel_repel(aes(label = name),
#box.padding = unit(0.5, "lines"),
data = gg,
size=2,
segment.colour = "black",
colour = "white", fill = "grey36")
gg <- ggnetwork(g)
ggplot(gg, aes(x = x, y = y, xend = xend, yend = yend)) +
geom_edges(aes(color = Color, linewidth = (mean_strength)), curvature = 0.0,
arrow = arrow(length = unit(5, "pt"), type = "closed")) + #makes arrows bigger
geom_nodes(color = "gray", size = degree(g, mode = "out"))+#, fill='black', stroke =2) +
scale_color_identity() +
theme_void() +
theme(legend.position = "none")  +
geom_nodelabel_repel(aes(label = name),
#box.padding = unit(0.5, "lines"),
data = gg,
size=2,
segment.colour = "black",
colour = "white", fill = "grey36")
ggplot(gg, aes(x = x, y = y, xend = xend, yend = yend)) +
geom_edges(aes(color = Color, linewidth = (mean_strength))) + #makes arrows bigger
geom_nodes(color = "gray", size = degree(g, mode = "out"))+#, fill='black', stroke =2) +
scale_color_identity() +
theme_void() +
theme(legend.position = "none")
saveRDS(yhats_rf, 'ostrich_ileum_rf_model')
saveRDS(bs_ostrich, 'bs_ostrich_ileum')
#racing =F works better for small samples or low prev data
saveRDS(yhats_rf_noX, 'ostrich_ileum_rf_noX')
#racing =F works better for small samples or low prev data
saveRDS(yhats_rf_noX1, 'ostrich_ileum_rf_noX1')
X1 <- Y_colonF
X <- X_colon
str(X)
Y <- Y_colonF #always use F
yhats_rf <- mrIMLpredicts(X=X, Y=Y,
X1=X1,
Model=model_rf , #lm/xgb not working on avian malaria
balance_data='no',
mode='classification',
tune_grid_size=5,
seed = sample.int(1e8, 1),
morans=F,
prop=0.7, k=5, racing=T)
str(X)
gc()
gc()
yhats_rf <- mrIMLpredicts(X=X, Y=Y,
X1=X1,
Model=model_rf , #lm/xgb not working on avian malaria
balance_data='no',
mode='classification',
tune_grid_size=5,
seed = 123,
morans=F,
prop=0.6, k=5, racing=T)
View(Y_ileum)
View(Y_caecum)
View(Y_caecumF)
glimpse(Y_colonF)
yhats_rf_noX1 <- mrIMLpredicts(X=X, Y=Y,
#X1=X1,
Model=model_rf , #lm/xgb not working on avian malaria
balance_data='no',
mode='classification',
tune_grid_size=5,
seed = 123,
morans=F,
prop=0.6, k=5, racing=T)
#explore the environmental/host covariates in more detail.
#factor box plots need to be fixed
covar <- mr_Covar(yhats_rf, X=X,X1=X1, Y=Y, var='Weight', sdthresh =0.04) #sdthrsh just plots taxa responding the most.
ModelPerf <- mrIMLperformance(yhats_rf_noX, Model=model_rf, Y=Y, mode='classification')
ModelPerf
Y_caecumF <- filterRareCommon(Y_caecum  , lower=0.3, higher=0.7) %>%
dplyr::select(sort(names(.)))
Y_colonF <- filterRareCommon(Y_colon  , lower=0.3, higher=0.7) %>%
dplyr::select(sort(names(.)))
X1 <- Y_colonF
X <- X_colon
str(X)
Y <- Y_colonF #always use F
gc()
yhats_rf <- readRDS('ostrich_ileum_rf_model')
#explore the environmental/host covariates in more detail.
#factor box plots need to be fixed
covar <- mr_Covar(yhats_rf, X=X,X1=X1, Y=Y, var='Weight', sdthresh =0.04) #sdthrsh just plots taxa responding the most.
X <- X_ileum
X1 <- Y_ileumF
X <- X_ileum
str(X)
Y <- Y_ileumF
#explore the environmental/host covariates in more detail.
#factor box plots need to be fixed
covar <- mr_Covar(yhats_rf, X=X,X1=X1, Y=Y, var='Weight', sdthresh =0.04) #sdthrsh just plots taxa responding the most.
#explore the environmental/host covariates in more detail.
#factor box plots need to be fixed
covar <- mr_Covar(yhats_rf, X=X,X1=X1, Y=Y, var='Age', sdthresh =0.04) #sdthrsh just plots taxa responding the most.
#explore the environmental/host covariates in more detail.
#factor box plots need to be fixed
covar <- mr_Covar(yhats_rf, X=X,X1=X1, Y=Y, var='Age', sdthresh =0.05) #sdthrsh just plots taxa responding the most.
gc()
#---------------------------------------------------------------------------------
#coinfection test data # from MRFcov. This data can also be used in this pipeline replacing X/Y
#---------------------------------------------------------------------------------
pacman::p_load('MRFcov', 'mrIML', 'tidyverse', 'future.apply','tidymodels', 'finetune',
'themis', 'vip', 'flashlight', 'iml', 'vivid', 'igraph', 'ggnetwork', 'network',
'gridExtra', 'xgboost', 'brulee', 'fastshap', 'tabnet', 'bonsai',
'parsnip','data.table', 'cowplot', 'progress', 'hstats', 'geosphere',
'DALEX', 'ingredients', 'shapr', 'shapviz', 'cowplot','kernelshap', 'doParallel',
'kernelshap', 'svMisc', 'ggplotify')
raw_data_beetles  <- read_excel("all taxa_ all sp_ mat sp.xlsx")
?read_excel
raw_predictors <- readexcel::read_excel("Site_covariates_decision_making_4.xlsx", sheet=4)
raw_predictors <- readxll::read_excel("Site_covariates_decision_making_4.xlsx", sheet=4)
setwd("~/MrIML")
raw_data_beetles  <- read_excel("all taxa_ all sp_ mat sp.xlsx")
install.packages("readxl")
pacman::p_load('MRFcov', 'mrIML', 'tidyverse', 'future.apply','tidymodels', 'finetune',
'themis', 'vip', 'flashlight', 'iml', 'vivid', 'igraph', 'ggnetwork', 'network',
'gridExtra', 'xgboost', 'brulee', 'fastshap', 'tabnet', 'bonsai',
'parsnip','data.table', 'cowplot', 'progress', 'hstats', 'geosphere',
'DALEX', 'ingredients', 'shapr', 'shapviz', 'cowplot','kernelshap', 'doParallel',
'kernelshap', 'svMisc', 'ggplotify', 'readxl')
raw_data_beetles  <- read_excel("all taxa_ all sp_ mat sp.xlsx")
raw_predictors <- read_excel("Site_covariates_decision_making_4.xlsx", sheet=4)
Y <- raw_data_beetles %>%  dplyr::select( -Site, -Distance, -Transect, -Age) %>%
rename_all(~gsub(" ", "_", .)) %>%  #make species have _
column_to_rownames(var = "Plot") %>% #make row ids
mutate_all(~ ifelse(. > 0, 1, .)) #convert to presence/absence
Y_filt <- filterRareCommon(Y, lower=0.2, higher=0.8)
Y_filt <- filterRareCommon(Y, lower=0.1, higher=0.8)
View(Y_filt)
X <- raw_predictors %>%  dplyr::select( -plot_code_T_D, -Transect,-Beetles_S_Mat_Indval2,-Beetle_S_Total,
-dist_regrowth, -Age,-Beetles_Mat_Ratio, -Birds_S_Mat_EFL, -Birds_S_Total,
-Birds_Mat_Ratio, -slope_f_Jayne) %>%
column_to_rownames(var = "plot_code") %>%
rename_all(~gsub(" ", "_", .))
View(X)
X$Site <- as.factor(X$Site)
X$geol_Jayne <- as.factor(X$geol_Jayne)
X1 <- Y #t
model_rf <-
rand_forest(trees = 1000, mode = "classification", mtry = tune(), min_n = tune()) %>% #100 trees are set for brevity. Aim to start with 1000
set_engine("randomForest")
cl <- parallel::makeCluster(5)
plan(cluster, workers=cl)
#with co-occurences
yhats_rf <- mrIMLpredicts(X=X, Y=Y,
X1=X1,#makes a GNM
Model=model_rf ,
balance_data='no',
mode='classification',
tune_grid_size=5,
seed = 123,
#      morans=F,
prop=0.7, k=5, racing=T)
#with co-occurences
yhats_rf <- mrIMLpredicts(X=X, Y=Y,
X1=X1,#makes a GNM
Model=model_rf ,
balance_data='no',
mode='classification',
tune_grid_size=5,
seed = 123,
#      morans=F,
prop=0.6, k=5, racing=T)
#with co-occurences
yhats_rf <- mrIMLpredicts(X=X, Y=Y,
X1=X1,#makes a GNM
Model=model_rf ,
balance_data='no',
mode='classification',
tune_grid_size=5,
seed = 123,
#      morans=F,
prop=0.6, k=5, racing=T)
Y_filt <- filterRareCommon(Y, lower=0.2, higher=0.7)
Y=Y_filt#for convenience
Y_filt <- filterRareCommon(Y, lower=0.3, higher=0.7)
Y <- raw_data_beetles %>%  dplyr::select( -Site, -Distance, -Transect, -Age) %>%
rename_all(~gsub(" ", "_", .)) %>%  #make species have _
column_to_rownames(var = "Plot") %>% #make row ids
mutate_all(~ ifelse(. > 0, 1, .)) #
Y_filt <- filterRareCommon(Y, lower=0.3, higher=0.7)
Y <- raw_data_beetles %>%  dplyr::select( -Site, -Distance, -Transect, -Age) %>%
rename_all(~gsub(" ", "_", .)) %>%  #make species have _
column_to_rownames(var = "Plot") %>% #make row ids
mutate_all(~ ifelse(. > 0, 1, .)) #convert to presence/absence
Y_filt <- filterRareCommon(Y, lower=0.3, higher=0.7)
Y_filt <- filterRareCommon(Y, lower=0.2, higher=0.7)
Y_filt <- filterRareCommon(Y, lower=0.3, higher=0.7)
Y_filt <- filterRareCommon(Y, lower=0.1, higher=0.7)
Y=Y_filt#fo
X1 <- Y #to
yhats_rf <- mrIMLpredicts(X=X, Y=Y,
X1=X1,#makes a GNM
Model=model_rf ,
balance_data='no',
mode='classification',
tune_grid_size=5,
seed = 123,
#      morans=F,
prop=0.6, k=5, racing=T)
ModelPerf <- mrIMLperformance(yhats_rf, Model=model_rf, Y=Y, mode='classification')
ModelPerf
View(ModelPerf)
m <- ModelPerf[[1]]
View(m)
bs_beetle <- mrBootstrap(yhats=yhats_rf, Y=Y, num_bootstrap = 50)
gc()
