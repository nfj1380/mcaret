lower=0.4,
higher=0.7)
Y <- fData #For simplicity when comparing
#Define set the outcomes of interest
str(Features)
#Remove NAs from the feature/predictor data.
FeaturesnoNA<-Features[complete.cases(Features), ]
X <- FeaturesnoNA #For simplicity
#For more efficient testing for interactions (more variables more interacting pairs)
X <- FeaturesnoNA[c(1:3)] #Three features only
yhats <- mrIMLpredicts(X=X, #Features/predictors
Y=Y, #Response data
Model=model1, #Specify your model
balance_data='no', #Chose how to balance your data
k=5,
racing = F,
mode='classification', #Chose your mode (classification versus regression)
seed = 120) #Set seed
#Define set of features
fData <- filterRareCommon (Responsedata,
lower=0.4,
higher=0.7)
Y <- fData #For simplicity when comparing
#Define set the outcomes of interest
str(Features)
#Remove NAs from the feature/predictor data.
FeaturesnoNA<-Features[complete.cases(Features), ]
X <- FeaturesnoNA #For simplicity
#For more efficient testing for interactions (more variables more interacting pairs)
X <- FeaturesnoNA[c(1:3)] #Three features only
yhats <- mrIMLpredicts(X=X, #Features/predictors
Y=Y, #Response data
Model=model1, #Specify your model
balance_data='no', #Chose how to balance your data
k=5,
racing = T,
mode='classification', #Chose your mode (classification versus regression)
seed = 120) #Set seed
pacman:: p_load(
vip, tidymodels, randomForest, caret, gbm,
tidyverse, parallel, doParallel, themis, viridis,
janitor, hrbrthemes, xgboost, vegan, flashlight,
ggrepel, iml, plyr, future.apply, gridExtra, cowplot, hstats
)
model1 <-
rand_forest(trees = 10, mode = "classification",
mtry = tune(),
min_n = tune()) %>% #100 trees are set for brevity
set_engine("randomForest")
fData <- filterRareCommon (Responsedata,
lower=0.4,
higher=0.7)
data <- fData[1:20]
Y <- fData #For simplicity when comparing
#Define set the outcomes of interest
str(Features)
#Remove NAs from the feature/predictor data.
FeaturesnoNA<-Features[complete.cases(Features), ]
X <- FeaturesnoNA #For simplicity
#For more efficient testing for interactions (more variables more interacting pairs)
X <- FeaturesnoNA[c(1:3)] #Three features only
yhats_rf <- mrIMLpredicts(X=X,Y=Y,
Model=model_rf, balance_data='no', mode='classification',k=5,  tune_grid_size=5,
seed = 123, racing=F )  #Set seed
model_rf <-
rand_forest(trees = 100, mode = "classification", mtry = tune(), min_n = tune()) %>% #100 trees are set for brevity. Aim to start with 1000
set_engine("randomForest")
Y <- fData #For simplicity when comparing
#Define set the outcomes of interest
str(Features)
#Remove NAs from the feature/predictor data.
FeaturesnoNA<-Features[complete.cases(Features), ]
X <- FeaturesnoNA #For simplicity
#For more efficient testing for interactions (more variables more interacting pairs)
X <- FeaturesnoNA[c(1:3)] #Three features only
yhats_rf <- mrIMLpredicts(X=X,Y=Y,
Model=model_rf, balance_data='no', mode='classification',k=5,  tune_grid_size=5,
seed = 123, racing=F )  #Set seed
ModelPerf <- mrIMLperformance(yhats=yhats,
Model=model1,
Y=Y, mode='classification')
Y <- fData #For simplicity when comparing
#Define set the outcomes of interest
str(Features)
#Remove NAs from the feature/predictor data.
FeaturesnoNA<-Features[complete.cases(Features), ]
X <- FeaturesnoNA #For simplicity
#For more efficient testing for interactions (more variables more interacting pairs)
X <- FeaturesnoNA[c(1:3)] #Three features only
yhats_rf <- mrIMLpredicts(X=X,Y=Y,
Model=model_rf, balance_data='no', mode='classification',k=5,  tune_grid_size=5,
seed = 123, racing=F )  #Set seed
ModelPerf <- mrIMLperformance(yhats=yhats_rf,
Model=model_rf,
Y=Y, mode='classification')
ModelPerf[[1]] #Predictive performance for individual responses
ModelPerf[[2]]#Overall predictive performance. r2 for regression and MCC for classification
VI <- mrvip(yhats_rf, X=X, Y=Y)
bs_impVI <- mrvip(
mrBootstrap_obj = NULL,
yhats = yhats_rf,
X = X,
Y = Y,
mode = 'classification',
threshold = 0.0,
global_top_var = 10,
local_top_var = 5,
taxa = 'pol_132',
ModelPerf = ModelPerf_rf
)
bs_impVI <- mrvip(
mrBootstrap_obj = NULL,
yhats = yhats_rf,
X = X,
Y = Y,
mode = 'classification',
threshold = 0.0,
global_top_var = 10,
local_top_var = 5,
taxa = 'pol_132',
ModelPerf = ModelPerf
)
bs_impVI[[3]] #importance
bs_impVI[[4]] #PCA
flashlightObj <- mrFlashlight(yhats_rf,
X=X,
Y=Y,
response = "single",
index=1,
mode='classification')
#plot prediction scatter for all responses. Gets busy with
plot(light_scatter(flashlightObj,
v = "Forest",
type = "predicted"))
#plots everything on one plot (partial dependency, ALE, scatter)
plot(light_effects(flashlightObj,
v = "Grassland"),
use = "all")
#profileData_pd <- light_profile(flashlightObj,  v = "Grassland")
#mrProfileplot(profileData_pd , sdthresh =0.05) #sdthresh removes responses from the first plot that do not vary with the feature
profileData_ale <- light_profile(flashlightObj,
v = "Grassland",
type = "ale") #accumulated local effects
mrProfileplot(profileData_ale,
sdthresh =0.01)
#the second plot is the cumulative turnover function
pacman::p_load('MRFcov', 'mrIML', 'tidyverse', 'future.apply','tidymodels', 'finetune', 'themis', 'vip', 'flashlight', 'iml', 'vivid', 'igraph', 'ggnetwork', 'network','gridExtra', 'xgboost', 'brulee', 'fastshap', 'tabnet', 'bonsai', 'parsnip', 'cowplot', 'progress', 'hstats', 'geosphere')
Y <- dplyr::select(Bird.parasites, -scale.prop.zos) %>%
dplyr::select(sort(names(.)))#response variables eg. SNPs, pathogens, species....
X <- dplyr::select(Bird.parasites, scale.prop.zos) # feature set
X1 <- Y %>%
dplyr::select(sort(names(.)))
X1_fact <- X1 %>%
mutate_all(as.factor) %>%
mutate_all(~ifelse(. == 0, "absent", "present"))
model_rf <-
rand_forest(trees = 100, mode = "classification", mtry = tune(), min_n = tune()) %>% #100 trees are set for brevity. Aim to start with 1000
set_engine("randomForest")
model_lm <- #model used to generate yhat
logistic_reg() %>%
set_engine("glm") %>%
set_mode("classification") #just for your response
cl <- parallel::makeCluster(5)
plan(cluster, workers=cl)
#random forest
yhats_rf <- mrIMLpredicts(X=X, Y=Y,
X1=X1,
Model=model_rf,
balance_data='no',
mode='classification',
seed = sample.int(1e8, 1),
morans=F,
prop=0.7, k=5, racing=T)
#linear model
yhats_lm <- mrIMLpredicts(X=X,Y=Y,
X1=X1_fact,
Model=model_lm ,
balance_data='no',
mode='classification',
seed = sample.int(1e8, 1),
prop=0.6, racing=F, k=5)
#source("~/MrIML/mrIML/R/mrPerformancePlot.R")
ModelPerf_rf <- mrIMLperformance(yhats_rf, Model=model_rf, Y=Y, mode='classification')
ModelPerf_rf[[1]] #across all parasites
ModelPerf_rf[[2]] #overall
ModelPerf_lm <- mrIMLperformance(yhats_lm, Model=model_lm, Y=Y, mode='classification')
ModelPerf_lm[[1]]
ModelPerf_lm[[2]]
plots <- mrPerformancePlot(ModelPerf1 =ModelPerf_lm, ModelPerf2 = ModelPerf_rf, mod_names=c('linear_reg','rand_forest'), mode='classification' )
plots
yhats_rf_noAssoc <- mrIMLpredicts(X=X, Y=Y,
X1=NULL, #no associations for this one
Model=model_rf,
balance_data='no',
mode='classification',
seed = sample.int(1e8, 1),
prop=0.7, k=5, racing=T)
ModelPerf_rf_noAssoc <- mrIMLperformance(yhats_rf_noAssoc, Model=model_rf, Y=Y, mode='classification')
ModelPerf_rf_noAssoc[[1]]
ModelPerf_rf[[1]] #performance including associations
cl <- parallel::makeCluster(5) #can increase the number of cores as needed.
plan(cluster, workers=cl)
#do bootstraps.
bs_malaria <- mrBootstrap(yhats=yhats_rf,Y=Y, #n
num_bootstrap = 10, downsample = FALSE, mode='classification')
source("~/MrIML/mrIML/R/mrBootstrap.R")
cl <- parallel::makeCluster(5) #can increase the number of cores as needed.
plan(cluster, workers=cl)
#do bootstraps.
bs_malaria <- mrBootstrap(yhats=yhats_rf,Y=Y, #n
num_bootstrap = 10, downsample = FALSE, mode='classification')
#make sure downsample=TRUE as this did improve performance
#just 10 bootstraps to keep this short. We suggest using more for a final analysis (100 is reasonable but depends on how big the data is)
#up to here -not working properly
bs_impVI <- mrvip(
mrBootstrap_obj = bs_malaria,
yhats = yhats_rf_downSamp,
X = X,
X1 = X1,
Y = Y,
mode = 'classification',
threshold = 0.0,
global_top_var = 10,
local_top_var = 5,
taxa = NULL,
ModelPerf = ModelPerf_rf_downSamp
)
yhats_rf_downSamp <- mrIMLpredicts(X=X, Y=Y,
X1=X1,
Model=model_rf ,
balance_data='down', #down sampling
mode='classification',
seed = sample.int(1e8, 1),
prop=0.75, k=5, racing=T)
ModelPerf_rf_downSamp <- mrIMLperformance(yhats_rf_downSamp, Model=model_rf, Y=Y, mode='classification')
ModelPerf_rf_downSamp[[1]]
#source("~/MrIML/mrIML/R/mrBootstrap.R")
cl <- parallel::makeCluster(5) #can increase the number of cores as needed.
plan(cluster, workers=cl)
#do bootstraps.
bs_malaria <- mrBootstrap(yhats=yhats_rf,Y=Y,
num_bootstrap = 10, downsample = FALSE, mode='classification')
#make sure downsample=TRUE as this did improve performance
#just 10 bootstraps to keep this short. We suggest using more for a final analysis (100 is reasonable but depends on how big the data is)
#up to here -not working properly
bs_impVI <- mrvip(
mrBootstrap_obj = bs_malaria,
yhats = yhats_rf_downSamp,
X = X,
X1 = X1,
Y = Y,
mode = 'classification',
threshold = 0.0,
global_top_var = 10,
local_top_var = 5,
taxa = NULL,
ModelPerf = ModelPerf_rf_downSamp
)
bs_impVI[[3]]  #importance plot. There are plenty of other insights possible
#the 'global_top_var' provides a limit to how many predictors are included in the community-wide plot. 'local_top_var provides a limit to the number of individual taxa plots. The threshold excludes plotting individual importance plots for taxa not well predicted by the model.
View(mrBootstrap)
View(mrBootstrap)
View(mrBootstrap)
pacman::p_load('MRFcov', 'mrIML', 'tidyverse', 'future.apply','tidymodels', 'finetune', 'themis', 'vip', 'flashlight', 'iml', 'vivid', 'igraph', 'ggnetwork', 'network','gridExtra', 'xgboost', 'brulee', 'fastshap', 'tabnet', 'bonsai', 'parsnip', 'cowplot', 'progress', 'hstats', 'geosphere')
Y <- dplyr::select(Bird.parasites, -scale.prop.zos) %>%
dplyr::select(sort(names(.)))#response variables eg. SNPs, pathogens, species....
X <- dplyr::select(Bird.parasites, scale.prop.zos) # feature set
X1 <- Y %>%
dplyr::select(sort(names(.)))
X1_fact <- X1 %>%
mutate_all(as.factor) %>%
mutate_all(~ifelse(. == 0, "absent", "present"))
model_rf <-
rand_forest(trees = 100, mode = "classification", mtry = tune(), min_n = tune()) %>% #100 trees are set for brevity. Aim to start with 1000
set_engine("randomForest")
model_lm <- #model used to generate yhat
logistic_reg() %>%
set_engine("glm") %>%
set_mode("classification") #just for your response
cl <- parallel::makeCluster(5)
plan(cluster, workers=cl)
#random forest
yhats_rf <- mrIMLpredicts(X=X, Y=Y,
X1=X1,
Model=model_rf,
balance_data='no',
mode='classification',
seed = sample.int(1e8, 1),
morans=F,
prop=0.7, k=5, racing=T)
#linear model
yhats_lm <- mrIMLpredicts(X=X,Y=Y,
X1=X1_fact,
Model=model_lm ,
balance_data='no',
mode='classification',
seed = sample.int(1e8, 1),
prop=0.6, racing=F, k=5)
ModelPerf_rf <- mrIMLperformance(yhats_rf, Model=model_rf, Y=Y, mode='classification')
ModelPerf_rf[[1]] #across all parasites
ModelPerf_rf[[2]] #overall
ModelPerf_lm <- mrIMLperformance(yhats_lm, Model=model_lm, Y=Y, mode='classification')
ModelPerf_lm[[1]]
ModelPerf_lm[[2]]
plots <- mrPerformancePlot(ModelPerf1 =ModelPerf_lm, ModelPerf2 = ModelPerf_rf, mod_names=c('linear_reg','rand_forest'), mode='classification' )
plots
yhats_rf_noAssoc <- mrIMLpredicts(X=X, Y=Y,
X1=NULL, #no associations for this one
Model=model_rf,
balance_data='no',
mode='classification',
seed = sample.int(1e8, 1),
prop=0.7, k=5, racing=T)
ModelPerf_rf_noAssoc <- mrIMLperformance(yhats_rf_noAssoc, Model=model_rf, Y=Y, mode='classification')
ModelPerf_rf_noAssoc[[1]]
ModelPerf_rf[[1]] #performance including associations
yhats_rf_downSamp <- mrIMLpredicts(X=X, Y=Y,
X1=X1,
Model=model_rf ,
balance_data='down', #down sampling
mode='classification',
seed = sample.int(1e8, 1),
prop=0.75, k=5, racing=T)
ModelPerf_rf_downSamp <- mrIMLperformance(yhats_rf_downSamp, Model=model_rf, Y=Y, mode='classification')
ModelPerf_rf_downSamp[[1]]
#source("~/MrIML/mrIML/R/mrBootstrap.R")
cl <- parallel::makeCluster(5) #can increase the number of cores as needed.
plan(cluster, workers=cl)
#do bootstraps.
bs_malaria <- mrBootstrap(yhats=yhats_rf,Y=Y,
num_bootstrap = 10, downsample = FALSE, mode='classification')
remove.packages("mrIML")
devtools::install_github('nfj1380/mrIML')
devtools::install_github('nfj1380/mrIML')
pacman::p_load('MRFcov', 'mrIML', 'tidyverse', 'future.apply','tidymodels', 'finetune', 'themis', 'vip', 'flashlight', 'iml', 'vivid', 'igraph', 'ggnetwork', 'network','gridExtra', 'xgboost', 'brulee', 'fastshap', 'tabnet', 'bonsai', 'parsnip', 'cowplot', 'progress', 'hstats', 'geosphere')
Y <- dplyr::select(Bird.parasites, -scale.prop.zos) %>%
dplyr::select(sort(names(.)))#response variables eg. SNPs, pathogens, species....
X <- dplyr::select(Bird.parasites, scale.prop.zos) # feature set
X1 <- Y %>%
dplyr::select(sort(names(.)))
X1_fact <- X1 %>%
mutate_all(as.factor) %>%
mutate_all(~ifelse(. == 0, "absent", "present"))
#source("~/MrIML/mrIML/R/mrBootstrap.R")
cl <- parallel::makeCluster(5) #can increase the number of cores as needed.
plan(cluster, workers=cl)
#do bootstraps.
bs_malaria <- mrBootstrap(yhats=yhats_rf,Y=Y,
num_bootstrap = 10, downsample = FALSE, mode='classification')
source("~/MrIML/mrIML/R/mrBootstrap.R")
#source("~/MrIML/mrIML/R/mrBootstrap.R")
cl <- parallel::makeCluster(5) #can increase the number of cores as needed.
plan(cluster, workers=cl)
#do bootstraps.
bs_malaria <- mrBootstrap(yhats=yhats_rf,Y=Y,
num_bootstrap = 10, downsample = FALSE, mode='classification')
#make sure downsample=TRUE as this did improve performance
#just 10 bootstraps to keep this short. We suggest using more for a final analysis (100 is reasonable but depends on how big the data is)
#up to here -not working properly
bs_impVI <- mrvip(
mrBootstrap_obj = bs_malaria,
yhats = yhats_rf_downSamp,
X = X,
X1 = X1,
Y = Y,
mode = 'classification',
threshold = 0.0,
global_top_var = 10,
local_top_var = 5,
taxa = NULL,
ModelPerf = ModelPerf_rf_downSamp
)
bs_impVI[[3]]  #importance plot. There are plenty of other insights possible
#the 'global_top_var' provides a limit to how many predictors are included in the community-wide plot. 'local_top_var provides a limit to the number of individual taxa plots. The threshold excludes plotting individual importance plots for taxa not well predicted by the model.
pacman::p_load('MRFcov', 'tidyverse', 'future.apply','tidymodels', 'finetune', 'themis', 'vip', 'flashlight', 'iml', 'vivid', 'igraph', 'ggnetwork', 'network','gridExtra', 'xgboost', 'brulee', 'fastshap', 'tabnet', 'bonsai', 'parsnip', 'cowplot', 'progress', 'hstats', 'geosphere', 'mrIML')
pacman::p_load('MRFcov', 'tidyverse', 'future.apply','tidymodels', 'finetune', 'themis', 'vip', 'flashlight', 'iml', 'vivid', 'igraph', 'ggnetwork', 'network','gridExtra', 'xgboost', 'brulee', 'fastshap', 'tabnet', 'bonsai', 'parsnip', 'cowplot', 'progress', 'hstats', 'geosphere', 'mrIML')
Y <- dplyr::select(Bird.parasites, -scale.prop.zos) %>%
dplyr::select(sort(names(.)))#response variables eg. SNPs, pathogens, species....
X <- dplyr::select(Bird.parasites, scale.prop.zos) # feature set
X1 <- Y %>%
dplyr::select(sort(names(.)))
X1_fact <- X1 %>%
mutate_all(as.factor) %>%
mutate_all(~ifelse(. == 0, "absent", "present"))
pacman::p_load('MRFcov', 'tidyverse', 'future.apply','tidymodels', 'finetune', 'themis', 'vip', 'flashlight', 'iml', 'vivid', 'igraph', 'ggnetwork', 'network','gridExtra', 'xgboost', 'brulee', 'fastshap', 'tabnet', 'bonsai', 'parsnip', 'cowplot', 'progress', 'hstats', 'geosphere', 'mrIML')
Y <- dplyr::select(Bird.parasites, -scale.prop.zos) %>%
dplyr::select(sort(names(.)))#response variables eg. SNPs, pathogens, species....
X <- dplyr::select(Bird.parasites, scale.prop.zos) # feature set
X1 <- Y %>%
dplyr::select(sort(names(.)))
X1_fact <- X1 %>%
mutate_all(as.factor) %>%
mutate_all(~ifelse(. == 0, "absent", "present"))
model_rf <-
rand_forest(trees = 100, mode = "classification", mtry = tune(), min_n = tune()) %>% #100 trees are set for brevity. Aim to start with 1000
set_engine("randomForest")
model_lm <- #model used to generate yhat
logistic_reg() %>%
set_engine("glm") %>%
set_mode("classification") #just for your response
cl <- parallel::makeCluster(5)
plan(cluster, workers=cl)
#random forest
yhats_rf <- mrIMLpredicts(X=X, Y=Y,
X1=X1,
Model=model_rf,
balance_data='no',
mode='classification',
seed = sample.int(1e8, 1),
morans=F,
prop=0.7, k=5, racing=T)
#linear model
yhats_lm <- mrIMLpredicts(X=X,Y=Y,
X1=X1_fact,
Model=model_lm ,
balance_data='no',
mode='classification',
seed = sample.int(1e8, 1),
prop=0.6, racing=F, k=5)
ModelPerf_rf <- mrIMLperformance(yhats_rf, Model=model_rf, Y=Y, mode='classification')
ModelPerf_rf[[1]] #across all parasites
ModelPerf_rf[[2]] #overall
ModelPerf_lm <- mrIMLperformance(yhats_lm, Model=model_lm, Y=Y, mode='classification')
ModelPerf_lm[[1]]
ModelPerf_lm[[2]]
plots <- mrPerformancePlot(ModelPerf1 =ModelPerf_lm, ModelPerf2 = ModelPerf_rf, mod_names=c('linear_reg','rand_forest'), mode='classification' )
plots
yhats_rf_noAssoc <- mrIMLpredicts(X=X, Y=Y,
X1=NULL, #no associations for this one
Model=model_rf,
balance_data='no',
mode='classification',
seed = sample.int(1e8, 1),
prop=0.7, k=5, racing=T)
ModelPerf_rf_noAssoc <- mrIMLperformance(yhats_rf_noAssoc, Model=model_rf, Y=Y, mode='classification')
ModelPerf_rf_noAssoc[[1]]
ModelPerf_rf[[1]] #performance including associations
yhats_rf_downSamp <- mrIMLpredicts(X=X, Y=Y,
X1=X1,
Model=model_rf ,
balance_data='down', #down sampling
mode='classification',
seed = sample.int(1e8, 1),
prop=0.75, k=5, racing=T)
ModelPerf_rf_downSamp <- mrIMLperformance(yhats_rf_downSamp, Model=model_rf, Y=Y, mode='classification')
ModelPerf_rf_downSamp[[1]]
source("~/MrIML/mrIML/R/mrBootstrap.R")
cl <- parallel::makeCluster(5) #can increase the number of cores as needed.
plan(cluster, workers=cl)
#do bootstraps.
bs_malaria <- mrBootstrap(yhats=yhats_rf,Y=Y,
num_bootstrap = 10, downsample = FALSE, mode='classification')
#make sure downsample=TRUE as this did improve performance
#just 10 bootstraps to keep this short. We suggest using more for a final analysis (100 is reasonable but depends on how big the data is)
#up to here -not working properly
bs_impVI <- mrvip(
mrBootstrap_obj = bs_malaria,
yhats = yhats_rf_downSamp,
X = X,
X1 = X1,
Y = Y,
mode = 'classification',
threshold = 0.0,
global_top_var = 10,
local_top_var = 5,
taxa = NULL,
ModelPerf = ModelPerf_rf_downSamp
)
bs_impVI[[3]]  #importance plot. There are plenty of other insights possible
#the 'global_top_var' provides a limit to how many predictors are included in the community-wide plot. 'local_top_var provides a limit to the number of individual taxa plots. The threshold excludes plotting individual importance plots for taxa not well predicted by the model.
rm(mrBootstrap)
#source("~/MrIML/mrIML/R/mrBootstrap.R")
cl <- parallel::makeCluster(5) #can increase the number of cores as needed.
plan(cluster, workers=cl)
#do bootstraps.
bs_malaria <- mrBootstrap(yhats=yhats_rf,Y=Y,
num_bootstrap = 10, downsample = FALSE, mode='classification')
#source("~/MrIML/mrIML/R/mrBootstrap.R")
cl <- parallel::makeCluster(5) #can increase the number of cores as needed.
plan(cluster, workers=cl)
#do bootstraps.
bs_malaria <- mrBootstrap(yhats=yhats_rf,Y=Y,
num_bootstrap = 10, downsample = TRUE, mode='classification')
#make sure downsample=TRUE as this did improve performance
#just 10 bootstraps to keep this short. We suggest using more for a final analysis (100 is reasonable but depends on how big the data is)
#up to here -not working properly
bs_impVI <- mrvip(
mrBootstrap_obj = bs_malaria,
yhats = yhats_rf_downSamp,
X = X,
X1 = X1,
Y = Y,
mode = 'classification',
threshold = 0.0,
global_top_var = 10,
local_top_var = 5,
taxa = NULL,
ModelPerf = ModelPerf_rf_downSamp
)
bs_impVI[[3]]  #importance plot. There are plenty of other insights possible
#the 'global_top_var' provides a limit to how many predictors are included in the community-wide plot. 'local_top_var provides a limit to the number of individual taxa plots. The threshold excludes plotting individual importance plots for taxa not well predicted by the model.
pds <- mrPD_bootstrap(mrBootstrap_obj=bs_malaria,
vi_obj=bs_impVI, X, Y,
target='Plas',
global_top_var=5)
#do bootstraps.
#source("~/MrIML/mrIML/R/MrBootstrap.R")
bs_malaria <- mrBootstrap(yhats=yhats_rf,Y=Y, #n
num_bootstrap = 10)
remove.packages("mrIML")
devtools::install_github('nfj1380/mrIML')
devtools::document()
